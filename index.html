<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polar Bears: The Sun‚Äôs Lethal Sentence</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="icon" href="assets/polar_bear.png" type="image/svg+xml" />
    <style>
        body { margin: 0; overflow-x: hidden; font-family: 'Segoe UI', sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        #app-container { transition: background-color 0.5s linear; }

        @keyframes twinkle {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(0.8); }
        }
        .star { animation: twinkle 3s infinite ease-in-out; }

        .tooltip { transition: opacity 0.5s ease, transform 0.5s ease; pointer-events: none; }
        .tooltip.hidden { opacity: 0; transform: translateY(20px); }
        .tooltip.visible { opacity: 1; transform: translateY(0); }

        .modal { transition: opacity 0.3s ease, pointer-events 0.3s ease; }
        .modal.hidden-modal { opacity: 0; pointer-events: none; }
        .modal.visible-modal { opacity: 1; pointer-events: auto; }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .section { min-height: 100vh; }
        .fade-in { opacity: 0; transform: translateY(30px); transition: opacity 0.8s ease, transform 0.8s ease; }
        .fade-in.visible { opacity: 1; transform: translateY(0); }

        .fact-card {
            position: relative;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        .fact-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }
        .fact-card:hover::before {
            left: 100%;
        }
        .fact-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(59, 130, 246, 0.3),
                inset 0 0 20px rgba(59, 130, 246, 0.1);
        }

        .quiz-card {
            position: relative;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(147, 197, 253, 0.15) 50%, rgba(59, 130, 246, 0.2) 100%);
            backdrop-filter: blur(15px);
            border: 2px solid transparent;
            background-clip: padding-box;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            padding: 1rem !important;
        }
        .quiz-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #3b82f6, #60a5fa, #93c5fd, #3b82f6);
            background-size: 200% 200%;
            border-radius: inherit;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease, background-position 3s ease;
            animation: borderShimmer 3s ease infinite;
        }
        .quiz-card:hover::before {
            opacity: 0.6;
        }
        @keyframes borderShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .quiz-card:hover {
            transform: translateY(-6px) scale(1.01);
            box-shadow: 
                0 20px 40px rgba(59, 130, 246, 0.4),
                0 0 60px rgba(59, 130, 246, 0.2),
                inset 0 0 30px rgba(59, 130, 246, 0.1);
            border-color: rgba(147, 197, 253, 0.8);
        }
        .quiz-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(147, 197, 253, 0.2) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .quiz-card:hover::after {
            opacity: 1;
        }

        .quiz-option {
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            overflow: hidden;
        }
        .quiz-option::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }
        .quiz-option:hover::before {
            width: 300px;
            height: 300px;
        }
        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.3);
        }
        .quiz-option.correct {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(74, 222, 128, 0.2) 100%);
            border-color: #22c55e;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
            animation: correctPulse 0.6s ease;
        }
        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .quiz-option.incorrect {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(248, 113, 113, 0.2) 100%);
            border-color: #ef4444;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
            animation: incorrectShake 0.5s ease;
        }
        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        .quiz-option.selected {
            border-color: rgba(147, 197, 253, 0.9);
            background: linear-gradient(135deg, rgba(147, 197, 253, 0.3) 0%, rgba(59, 130, 246, 0.2) 100%);
            box-shadow: 0 0 25px rgba(147, 197, 253, 0.5);
            transform: scale(1.02);
        }

        .guess-input {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 2px solid rgba(147, 197, 253, 0.4);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .guess-input:focus {
            border-color: rgba(59, 130, 246, 0.8);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%);
            outline: none;
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.4);
            transform: scale(1.02);
        }

        .reveal-btn {
            transition: all 0.3s ease;
        }
        .reveal-btn:hover {
            transform: scale(1.05);
        }

        .next-quiz-btn, .restart-quiz-btn {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        #sequential-quiz-container {
            min-height: 400px;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        #sequential-quiz-container::-webkit-scrollbar {
            width: 6px;
        }
        
        #sequential-quiz-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        #sequential-quiz-container::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 3px;
        }
        
        #sequential-quiz-container::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }

        .hidden-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease, opacity 0.3s ease;
            opacity: 0;
        }
        .hidden-content.revealed {
            max-height: 500px;
            opacity: 1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        @keyframes slideIn {
            from { transform: translateX(-100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes snowfall {
            0% {
                transform: translateY(-100px) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh + 100px)) translateX(var(--drift));
                opacity: 0;
            }
        }

        .snowflake {
            position: absolute;
            top: -50px;
            color: white;
            font-size: 1em;
            animation: snowfall linear infinite;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }

        #icebergs-container {
            transition: opacity 0.1s ease, transform 0.1s ease;
        }

        .iceberg {
            position: absolute;
            bottom: 0;
            opacity: 0.9;
            filter: blur(0.5px);
        }

        .iceberg-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .iceberg-above {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(240, 248, 255, 0.95) 50%, rgba(220, 235, 255, 0.9) 100%);
            clip-path: polygon(0% 60%, 5% 40%, 15% 25%, 30% 15%, 50% 10%, 70% 15%, 85% 25%, 95% 40%, 100% 60%, 100% 100%, 0% 100%);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40%;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.2), inset 0 5px 10px rgba(255, 255, 255, 0.3);
        }

        .iceberg-below {
            background: linear-gradient(180deg, rgba(100, 150, 200, 0.6) 0%, rgba(60, 100, 150, 0.5) 50%, rgba(40, 70, 120, 0.4) 100%);
            clip-path: polygon(0% 0%, 5% 5%, 15% 10%, 30% 15%, 50% 18%, 70% 15%, 85% 10%, 95% 5%, 100% 0%, 98% 20%, 90% 40%, 75% 60%, 50% 70%, 25% 60%, 10% 40%, 2% 20%);
            position: absolute;
            top: 40%;
            left: 0;
            width: 100%;
            height: 60%;
            box-shadow: inset 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .water-line {
            position: absolute;
            top: 40%;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        @keyframes icebergFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        .iceberg-1 { animation: icebergFloat 8s ease-in-out infinite; }
        .iceberg-2 { animation: icebergFloat 10s ease-in-out infinite 1s; }
        .iceberg-3 { animation: icebergFloat 12s ease-in-out infinite 2s; }
        .iceberg-4 { animation: icebergFloat 9s ease-in-out infinite 0.5s; }

        .section-divider {
            height: 0;
            display: none;
        }

        .transition-wave {
            display: none;
        }

        .narrative-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
        }
        .narrative-content {
            max-width: 800px;
            text-align: center;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        .narrative-content.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .season-facts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 3rem;
        }
        .season-fact-card {
            position: relative;
            padding: 2.5rem;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(30, 58, 138, 0.15) 50%, rgba(59, 130, 246, 0.2) 100%);
            backdrop-filter: blur(15px);
            border-radius: 1.5rem;
            border: 2px solid transparent;
            background-clip: padding-box;
            opacity: 0;
            transform: translateY(30px) scale(0.95);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            cursor: pointer;
        }
        
        .fact-content-hidden {
            filter: blur(8px);
            opacity: 0.3;
            transition: all 0.5s ease;
            pointer-events: none;
        }
        
        .fact-content-revealed {
            filter: blur(0px);
            opacity: 1;
            transition: all 0.8s ease;
        }
        
        .fact-reveal-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.4) 0%, rgba(147, 197, 253, 0.3) 100%);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: opacity 0.5s ease, transform 0.5s ease;
            border-radius: 1.5rem;
        }
        
        .fact-reveal-overlay.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
        }
        
        .reveal-button {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.8) 0%, rgba(147, 197, 253, 0.6) 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.75rem;
            color: white;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .reveal-button:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(59, 130, 246, 0.6);
            background: linear-gradient(135deg, rgba(59, 130, 246, 1) 0%, rgba(147, 197, 253, 0.8) 100%);
        }
        
        .fact-stat-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.3) 0%, rgba(245, 158, 11, 0.2) 100%);
            border: 1px solid rgba(251, 191, 36, 0.5);
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 700;
            color: #fbbf24;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s ease;
            z-index: 15;
        }
        
        .season-fact-card:hover .fact-stat-badge {
            opacity: 1;
            transform: scale(1);
        }
        
        .fact-mystery-text {
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 50%, #1e40af 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        .season-fact-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #3b82f6, #60a5fa, #1e40af, #3b82f6);
            background-size: 300% 300%;
            border-radius: inherit;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
            animation: cardBorderFlow 4s ease infinite;
        }
        @keyframes cardBorderFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .season-fact-card:hover::before {
            opacity: 0.7;
        }
        .season-fact-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, #60a5fa, transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }
        .season-fact-card:hover::after {
            transform: translateX(100%);
        }
        .season-fact-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .season-fact-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.4),
                0 0 40px rgba(59, 130, 246, 0.4),
                inset 0 0 30px rgba(59, 130, 246, 0.1);
        }

        #day-checkpoint-panel {
            opacity: 0;
            transform: scale(0.92);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }
        #day-checkpoint-panel.visible {
            opacity: 1;
            transform: scale(1);
        }
        
        .story-point {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 1.5rem;
            padding: 3rem;
            margin-bottom: 2rem;
            text-align: left;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        .story-point.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .story-point h3 {
            font-size: 2.25rem;
            font-weight: 800;
            margin-bottom: 1rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 0.5rem;
        }
        .story-point p {
            font-size: 1.15rem;
            line-height: 1.6;
        }
        .takeaway-final {
            position: relative;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 25%, #2d1b3d 50%, #1a1f3a 75%, #0a0e27 100%);
            padding: 3rem 2rem;
            border-radius: 2rem;
            border: 2px solid transparent;
            background-clip: padding-box;
            box-shadow: 
                0 0 60px rgba(220, 38, 38, 0.4),
                0 0 120px rgba(239, 68, 68, 0.2),
                inset 0 0 60px rgba(59, 130, 246, 0.1);
            margin-top: 5rem;
            margin-bottom: 5rem;
            text-align: center;
            overflow: hidden;
        }
        
        .takeaway-final::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(220, 38, 38, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(59, 130, 246, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(239, 68, 68, 0.15) 0%, transparent 70%);
            animation: pulseGlow 4s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes pulseGlow {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        
        .takeaway-final::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                #dc2626, #ef4444, #3b82f6, #60a5fa, #dc2626);
            background-size: 300% 300%;
            border-radius: 2rem;
            z-index: -1;
            animation: borderFlow 8s ease infinite;
            opacity: 0.8;
        }
        
        @keyframes borderFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .takeaway-final h2 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ffffff 0%, #fbbf24 30%, #ef4444 60%, #60a5fa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
            animation: titleShimmer 3s ease-in-out infinite;
        }
        
        @keyframes titleShimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        .takeaway-final p {
            font-size: 1rem;
            font-weight: 400;
            color: #e2e8f0;
            line-height: 1.8;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .takeaway-final h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        
        @media (max-width: 768px) {
            .takeaway-final {
                padding: 2rem 1.5rem;
            }
            
            .takeaway-final h2 {
                font-size: 2rem;
            }
            
            .takeaway-stat-number {
                font-size: 1.5rem;
            }
            
            .takeaway-stat-label {
                font-size: 0.65rem;
            }
        }
        
        /* Slider Styling */
        .slider-custom {
            -webkit-appearance: none;
            appearance: none;
        }
        
        .slider-custom::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);
            transition: all 0.3s ease;
        }
        
        .slider-custom::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.8);
        }
        
        .slider-custom::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);
            transition: all 0.3s ease;
        }
        
        .slider-custom::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.8);
        }
        
        .slider-custom::-webkit-slider-runnable-track {
            height: 12px;
            border-radius: 6px;
        }
        
        .slider-custom::-moz-range-track {
            height: 12px;
            border-radius: 6px;
        }
        
        .takeaway-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            position: relative;
            z-index: 1;
        }
        
        .takeaway-stat {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(20px);
            animation: statFadeIn 0.6s ease forwards;
        }
        
        @keyframes statFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .takeaway-stat:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(239, 68, 68, 0.5);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.3);
        }
        
        .takeaway-stat-number {
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ef4444 0%, #fbbf24 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
        }
        
        .takeaway-stat-label {
            font-size: 0.75rem;
            color: #cbd5e1;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }
        
        .takeaway-stats {
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .takeaway-stat {
            padding: 1rem;
        }
        
        .takeaway-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
            filter: drop-shadow(0 0 20px rgba(239, 68, 68, 0.5));
            animation: iconFloat 3s ease-in-out infinite;
        }
        
        
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .chart-tooltip {
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #ice-daylight-chart {
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        #chart-svg {
            overflow: visible;
        }
    </style>
</head>

<body class="bg-gray-900 text-white">

    <section id="intro-section" class="section relative flex items-center justify-center bg-gradient-to-b from-gray-900 via-blue-900 to-indigo-900 overflow-hidden min-h-screen">
        <!-- Enhanced background with more depth -->
        <div class="absolute inset-0 opacity-20">
            <div class="absolute top-20 left-10 w-96 h-96 bg-blue-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-20 right-10 w-96 h-96 bg-indigo-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1s;"></div>
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-96 h-96 bg-cyan-500 rounded-full blur-3xl opacity-30"></div>
        </div>
        
        <!-- Snowflake overlay -->
        <div class="absolute inset-0 opacity-40">
            <div class="absolute top-10 left-1/4 w-2 h-2 bg-white rounded-full blur-sm animate-pulse" style="animation-delay: 0.5s;"></div>
            <div class="absolute top-20 right-1/4 w-1.5 h-1.5 bg-white rounded-full blur-sm animate-pulse" style="animation-delay: 1.5s;"></div>
            <div class="absolute bottom-20 left-1/3 w-2.5 h-2.5 bg-white rounded-full blur-sm animate-pulse" style="animation-delay: 2s;"></div>
        </div>

        <div id="snow-container" class="absolute inset-0 overflow-hidden pointer-events-none z-10"></div>

        <div id="icebergs-container" class="absolute bottom-0 left-0 right-0 h-80 pointer-events-none z-5">
            <div class="iceberg iceberg-1" style="left: 0%; width: 350px; height: 240px;">
                <div class="iceberg-container w-full h-full">
                    <div class="iceberg-above"></div>
                    <div class="iceberg-below"></div>
                    <div class="water-line"></div>
                </div>
                <!-- Cute Polar Bear on Iceberg -->
                <svg class="absolute" style="bottom: 65%; left: 50%; transform: translateX(-50%); width: 140px; height: 120px; z-index: 10;" viewBox="0 0 140 120">
                    <!-- Body (rounder and cuter) -->
                    <ellipse cx="70" cy="75" rx="40" ry="30" fill="#ffffff" opacity="0.98"/>
                    <!-- Head (bigger and rounder) -->
                    <circle cx="70" cy="35" r="28" fill="#ffffff" opacity="0.98"/>
                    <!-- Ears (rounder) -->
                    <circle cx="50" cy="18" r="9" fill="#ffffff" opacity="0.98"/>
                    <circle cx="90" cy="18" r="9" fill="#ffffff" opacity="0.98"/>
                    <!-- Inner ears -->
                    <circle cx="50" cy="18" r="5" fill="#e5e7eb" opacity="0.6"/>
                    <circle cx="90" cy="18" r="5" fill="#e5e7eb" opacity="0.6"/>
                    <!-- Big cute eyes -->
                    <circle cx="62" cy="32" r="4.5" fill="#1f2937"/>
                    <circle cx="78" cy="32" r="4.5" fill="#1f2937"/>
                    <!-- Eye highlights -->
                    <circle cx="63.5" cy="30.5" r="1.5" fill="#ffffff"/>
                    <circle cx="79.5" cy="30.5" r="1.5" fill="#ffffff"/>
                    <!-- Small cute nose -->
                    <ellipse cx="70" cy="40" rx="3" ry="2.5" fill="#1f2937"/>
                    <!-- Smile -->
                    <path d="M 65 45 Q 70 50 75 45" stroke="#1f2937" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                    <!-- Front legs (sitting position) -->
                    <ellipse cx="55" cy="85" rx="10" ry="18" fill="#ffffff" opacity="0.98"/>
                    <ellipse cx="85" cy="85" rx="10" ry="18" fill="#ffffff" opacity="0.98"/>
                    <!-- Back legs (sitting position) -->
                    <ellipse cx="60" cy="95" rx="8" ry="15" fill="#ffffff" opacity="0.98"/>
                    <ellipse cx="80" cy="95" rx="8" ry="15" fill="#ffffff" opacity="0.98"/>
                    <!-- Paws (cute rounded) -->
                    <ellipse cx="55" cy="100" rx="7" ry="5" fill="#1f2937" opacity="0.2"/>
                    <ellipse cx="85" cy="100" rx="7" ry="5" fill="#1f2937" opacity="0.2"/>
                    <ellipse cx="60" cy="107" rx="6" ry="4" fill="#1f2937" opacity="0.2"/>
                    <ellipse cx="80" cy="107" rx="6" ry="4" fill="#1f2937" opacity="0.2"/>
                </svg>
            </div>
            
            <div class="iceberg iceberg-2" style="left: 25%; width: 400px; height: 260px;">
                <div class="iceberg-container w-full h-full">
                    <div class="iceberg-above"></div>
                    <div class="iceberg-below"></div>
                    <div class="water-line"></div>
                </div>
            </div>
            
            <div class="iceberg iceberg-3" style="left: 55%; width: 380px; height: 250px;">
                <div class="iceberg-container w-full h-full">
                    <div class="iceberg-above"></div>
                    <div class="iceberg-below"></div>
                    <div class="water-line"></div>
                </div>
            </div>
            
            <div class="iceberg iceberg-4" style="left: 80%; width: 320px; height: 220px;">
                <div class="iceberg-container w-full h-full">
                    <div class="iceberg-above"></div>
                    <div class="iceberg-below"></div>
                    <div class="water-line"></div>
                </div>
            </div>
        </div>

        <div class="relative z-20 text-center px-6 max-w-4xl mx-auto fade-in">
            <h1 class="text-5xl md:text-7xl font-black tracking-tighter mb-6 drop-shadow-2xl">
                <span class="text-white">UNBEARABLE LIGHT</span><br/>
            </h1>
            <p class="text-xl md:text-2xl text-blue-100 mb-8 leading-relaxed drop-shadow-lg text-center mx-auto max-w-3xl">
                In the Arctic, polar bears are perfectly built for 24 hours of darkness. But the moment the sun refuses to set, the clock starts ticking on its demise.
            </p>
            <p class="text-lg text-blue-200/80 mb-12 drop-shadow-md text-center mx-auto max-w-2xl">
                Scroll down to explore the deadly extremes of the Arctic light cycle.
            </p>

            <div class="flex justify-center animate-bounce">
                <i data-lucide="arrow-down" class="w-8 h-8 text-white/60"></i>
            </div>
        </div>
    </section>

    <section id="hook-section" class="relative" style="height: 600vh;">
        <div class="sticky top-0 w-full h-screen overflow-hidden bg-gradient-to-b from-blue-900 via-blue-800 to-blue-900">
            <!-- Snowflakes for transition -->
            <div id="map-snow-container" class="absolute inset-0 overflow-hidden pointer-events-none z-10"></div>
            
            <div id="map-container" class="absolute inset-0 flex items-center justify-center">
                <svg id="arctic-map" class="w-full h-full" viewBox="0 0 3600 1800" preserveAspectRatio="xMidYMid meet">
                    <rect width="3600" height="1800" fill="#0f172a"/>
                    
                    <g id="world-map"></g>
                    
                    <g id="location-marker"></g>
                    
                    <g id="map-labels">
                        <text id="alaska-label" fill="#ffffff" font-size="48" font-weight="bold" text-anchor="middle" opacity="0">ALASKA</text>
                        <text id="city-label" fill="#ffffff" font-size="32" font-weight="bold" text-anchor="middle" opacity="0">Utqiagvik</text>
                    </g>
                </svg>
            </div>
            
            <div id="map-text-overlay" class="absolute inset-0 flex items-start justify-center pt-20 md:pt-32 z-20 pointer-events-none" style="opacity: 1;">
                <div class="text-center px-6 max-w-4xl">
                    <h2 id="map-title" class="text-4xl md:text-6xl font-black tracking-tighter mb-6 drop-shadow-2xl text-white">
                        WHERE IN THE ARCTIC?
                    </h2>
                    <p id="map-description" class="text-xl text-blue-100 mb-8 leading-relaxed drop-shadow-lg max-w-3xl mx-auto">
                        We're focusing on Utqiagvik, Alaska, the northernmost city in the United States, deep inside Polar Bear Territory.
                    </p>
                </div>
            </div>
            
            <div id="map-blur-overlay" class="absolute inset-0 z-25 pointer-events-none opacity-0 transition-opacity duration-1000" style="backdrop-filter: blur(10px); background: rgba(0, 0, 0, 0.5);">
                <div class="absolute inset-0 flex items-start justify-center pt-20 md:pt-32">
                    <div class="text-center px-6 max-w-4xl">
                        <p id="map-reason" class="text-xl text-white mb-12 drop-shadow-2xl max-w-3xl mx-auto font-semibold leading-relaxed">
                            This location experiences extreme seasonal variations in daylight, from 24 hour night to the 24 hour midnight sun, making it the perfect lens to see how polar bears adapt.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <div id="loading-screen" class="fixed inset-0 z-[60] bg-gray-900 flex flex-col items-center justify-center transition-opacity duration-500" style="opacity: 1; display: flex;">
        <div class="loader mb-4"></div>
        <p class="text-blue-200 text-sm tracking-widest uppercase">Loading Arctic Data...</p>
        <p id="loading-subtext" class="text-blue-200/50 text-xs mt-2">Initializing...</p>
        <div id="loading-progress" class="mt-4 w-64 h-1 bg-white/10 rounded-full overflow-hidden">
            <div id="loading-progress-bar" class="h-full bg-blue-400 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <p class="text-blue-300/50 text-xs mt-4">If this doesn't disappear, check the browser console (F12)</p>
    </div>
    
    <script>
        // IMMEDIATE TEST - This should run right away
        console.log("=== PAGE LOADING TEST ===");
        console.log("Script is running!");
        console.log("Document readyState:", document.readyState);
        
        // Test if we can access the loading screen
        setTimeout(function() {
            const ls = document.getElementById("loading-screen");
            console.log("Loading screen element:", ls ? "FOUND" : "NOT FOUND");
            if(ls) {
                console.log("Loading screen opacity:", ls.style.opacity);
                console.log("Loading screen display:", ls.style.display);
            }
        }, 500);
    </script>

    <section id="visualization-section" class="relative" style="height: 400vh;">

        <div id="app-container" class="sticky top-0 w-full h-screen overflow-hidden opacity-0 transition-opacity duration-1000 z-10">
            <div id="stars-layer" class="absolute inset-0 transition-opacity duration-1000"></div>
            <div id="clouds-layer" class="absolute inset-0 pointer-events-none mix-blend-overlay transition-opacity duration-1000"
                  style="background: repeating-linear-gradient(45deg, transparent, transparent 100px, rgba(255,255,255,0.1) 100px, rgba(255,255,255,0.1) 200px);">
            </div>

            <div id="cloud-visual-container"></div>

            <div class="absolute inset-0 flex items-end justify-center pb-20 pointer-events-none">
                <div id="celestial-body" class="relative w-[150vw] h-[150vw] rounded-full border border-white/5 transition-transform duration-75 linear origin-center">
                    <div class="absolute top-1/2 -right-12 w-24 h-24 bg-yellow-300 rounded-full blur-xl shadow-[0_0_100px_rgba(253,224,71,0.6)]"></div>
                    <div class="absolute top-1/2 -right-12 w-24 h-24 bg-yellow-100 rounded-full shadow-2xl"></div>
                    <div class="absolute top-1/2 -left-12 w-20 h-20 bg-gray-200 rounded-full shadow-[0_0_50px_rgba(255,255,255,0.2)] opacity-80">
                        <div class="w-4 h-4 bg-gray-300 rounded-full absolute top-4 left-4 opacity-50"></div>
                        <div class="w-6 h-6 bg-gray-300 rounded-full absolute bottom-6 right-6 opacity-50"></div>
                    </div>
                </div>
            </div>

            <div class="absolute inset-0 flex flex-col justify-between p-6 md:p-12 z-50 pointer-events-none">
                <div class="flex justify-between items-start pointer-events-auto">

                    <div class="bg-black/40 backdrop-blur-md rounded-2xl p-6 border-2 border-white/20 shadow-2xl">
                        <h1 class="text-4xl md:text-6xl font-black tracking-tighter drop-shadow-lg">
                            POLAR BEAR<br/>
                            <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-300 via-cyan-300 to-white">
                                HABITAT
                            </span>
                        </h1>
                        <p class="text-blue-100 mt-2 max-w-md drop-shadow-md text-sm md:text-base">
                            Toggle through seasons. Experience a polar bear's varying 24 hour cycle in the Arctic.
                        </p>
                    </div>

                    <div class="hidden md:block text-right bg-black/40 backdrop-blur-md rounded-2xl p-6 border-2 border-white/20 shadow-2xl">
                        <p class="text-white/60 text-sm uppercase tracking-widest">Current Time</p>
                        <p id="time-display" class="text-6xl font-mono font-bold tabular-nums drop-shadow-lg">00:00</p>
                    </div>
                </div>

                <div id="tooltip-container" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-4xl h-full pointer-events-none"></div>

                <div class="pointer-events-auto space-y-6 w-full">
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div class="bg-black/40 backdrop-blur-md border-2 border-white/20 p-4 rounded-xl flex items-center shadow-2xl">
                            <div id="vis-brightness" class="w-16 h-16 mr-4 flex items-center justify-center"></div>
                            <div>
                                <p class="text-blue-200 text-xs font-medium uppercase tracking-wider">Brightness Index</p>
                                <p id="val-brightness" class="text-2xl font-bold">0</p>
                            </div>
                        </div>

                        <div class="bg-black/40 backdrop-blur-md border-2 border-white/20 p-4 rounded-xl flex items-center shadow-2xl">
                            <div id="vis-cloud" class="w-16 h-16 mr-4 flex items-center justify-center"></div>
                            <div>
                                <p class="text-blue-200 text-xs font-medium uppercase tracking-wider">Cloud Cover</p>
                                <p id="val-cloud" class="text-2xl font-bold">0%</p>
                            </div>
                        </div>

                        <div class="bg-black/40 backdrop-blur-md border-2 border-white/20 p-4 rounded-xl flex items-center space-x-4 shadow-2xl">
                            <i data-lucide="clock" class="text-blue-300 w-6 h-6"></i>
                            <div>
                                <p class="text-blue-200 text-xs font-medium uppercase tracking-wider">Daylight Hours</p>
                                <p id="val-daylight" class="text-2xl font-bold">0h</p>
                                <p class="text-[10px] text-blue-300/60 uppercase">Seasonal Avg</p>
                            </div>
                        </div>

                        <div class="bg-black/40 backdrop-blur-md border-2 border-white/20 p-4 rounded-xl flex flex-col justify-center space-y-2 shadow-2xl">
                            <span class="text-blue-200 text-xs font-medium uppercase tracking-wider">Season</span>
                            <div class="flex space-x-1 bg-black/20 p-1 rounded-lg" id="season-controls"></div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div id="location-display" class="bg-black/40 backdrop-blur-md rounded-2xl p-4 border-2 border-white/20 text-center transition-all duration-300 shadow-2xl">
                            <p class="text-blue-200 text-xs font-medium uppercase tracking-wider mb-1">Current Location</p>
                            <p id="current-location-text" class="text-white text-lg font-bold transition-opacity duration-300">Utqiagvik, Alaska</p>
                            <p id="location-description" class="text-blue-300/70 text-xs mt-1 transition-opacity duration-300">Polar Bear Territory</p>
                        </div>

                        <div id="year-progress" class="bg-black/40 backdrop-blur-md rounded-2xl p-4 border-2 border-white/20 text-center transition-all duration-300 shadow-2xl">
                            <p class="text-blue-200 text-xs font-medium uppercase tracking-wider mb-1">24-Hour Arctic Cycle</p>
                            <p id="year-season" class="text-white text-lg font-bold">00:00</p>
                            <div class="mt-2 w-full bg-white/10 rounded-full h-2">
                                <div id="year-progress-bar" class="bg-gradient-to-r from-blue-400 to-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                            <p class="text-blue-300/60 text-xs mt-1">Progress through the day</p>
                        </div>
                    </div>

                    <div id="scroll-hint" class="text-center w-full pb-4">
                        <p class="text-white text-xs uppercase tracking-widest animate-bounce" id="scroll-hint-text">Scroll to experience a polar bear's 24 hour day</p>
                        <p id="lock-message" class="text-yellow-300 text-sm mt-2 font-semibold hidden">Complete the 24 hour cycle to continue</p>
                    </div>
                </div>
            </div>
        </div>

    </section>

    <!-- Bridge Section: Connecting 24-hour cycle to seasonal changes -->
    <section id="story-bridge-section" class="section bg-gradient-to-b from-blue-900 via-gray-900 to-gray-900 py-16 px-6 flex items-center justify-center relative">
        <div class="max-w-4xl mx-auto">
            <div class="bg-black/40 backdrop-blur-md rounded-2xl p-8 md:p-10 border-2 border-blue-500/30 shadow-2xl">
                <div class="text-center mb-6">
                    <div class="text-5xl mb-4">‚è∞</div>
                    <h2 class="text-3xl md:text-4xl font-black tracking-tighter mb-4 drop-shadow-lg">
                        <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-300 via-cyan-300 to-white">FROM ONE DAY TO SEASONS</span>
                    </h2>
                </div>
                <p class="text-lg md:text-xl leading-relaxed text-blue-100 mb-4 text-center">
                    What you just experienced in the 24 hour cycle above happens every single day. But as the seasons change, the pattern shifts dramatically.
                </p>
                <p class="text-base leading-relaxed text-blue-200/90 mb-4 text-center">
                    In <strong class="text-white">winter</strong>, those 24 hours are mostly darkness, with ice remaining solid. In <strong class="text-yellow-300">summer</strong>, those same 24 hours bring endless daylight, but the ice beneath their paws melts away. The daily cycle you witnessed repeats 365 times, but each season transforms what that cycle means for survival.
                </p>
                <p class="text-base leading-relaxed text-blue-200/90 text-center">
                    The charts below show how this daily pattern compounds over months. The same relationship between daylight and ice that you saw in one day plays out across an entire year, with devastating consequences.
                </p>
            </div>
        </div>
    </section>

    <section id="narrative-storytelling-section" class="section bg-gray-900 py-12 px-6 flex items-center justify-center relative">
        <div class="max-w-4xl mx-auto">
            <h2 class="text-4xl md:text-5xl font-black tracking-tighter mb-8 drop-shadow-lg text-center">
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-white to-blue-300">THE ARCTIC PARADOX</span>
            </h2>

            <div id="story-but" class="story-point visible">
                <i data-lucide="thermometer-snowflake" class="w-7 h-7 text-red-400 mb-3"></i>
                <h3 class="text-red-400 text-2xl font-black mb-3">The Lethality of Summer Heat</h3>
                <p class="text-base leading-relaxed mb-3">
                    Imagine surviving on stored fat for months. No food. No way to hunt. Just waiting, starving, as your body consumes itself. This is the reality for polar bears in summer.
                </p>
                <p class="text-base leading-relaxed mb-4">
                    With climate change, the Arctic's summer is seeing dramatic ice melt, often occurring weeks earlier and lasting months longer. This extended ice-free season forces bears off their hunting grounds and onto land. Instead of hunting, they must enter a prolonged, life-threatening fasting period, surviving only on stored fat.
                </p>
            </div>
            
            <!-- Engaging text block after BUT section -->
            <div class="mt-8 max-w-4xl mx-auto fade-in">
                <div class="bg-gradient-to-r from-gray-800/60 via-slate-800/60 to-gray-800/60 backdrop-blur-sm rounded-xl p-6 border-2 border-gray-600/30 shadow-xl">
                    <div class="flex items-start gap-3">
                        <div class="text-3xl">üí≠</div>
                        <div class="flex-1">
                            <h3 class="text-xl font-black text-white mb-2 bg-gradient-to-r from-gray-200 to-blue-200 bg-clip-text text-transparent">
                                A Question That Haunts
                            </h3>
                            <p class="text-base leading-relaxed text-gray-200 mb-2">
                                We often think of polar bears as masters of the cold, perfectly adapted to survive in temperatures that would kill us in minutes. And they are. But their greatest enemy isn't the cold, it's the warmth that takes away their world.
                            </p>
                            <p class="text-sm leading-relaxed text-gray-300/90">
                                As you explore the visualizations ahead, remember: every data point represents a real bear, a real struggle, a real life hanging in the balance. The charts aren't just showing numbers‚Äîthey're showing a countdown to extinction if we don't act.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section id="chart-section" class="section bg-gradient-to-b from-gray-900 via-blue-900 to-gray-900 py-20 px-6 min-h-screen flex items-center justify-center relative">
        <div class="max-w-6xl mx-auto w-full">
            <div class="text-center mb-12 fade-in">
                <h2 class="text-4xl md:text-6xl font-black tracking-tighter mb-4 drop-shadow-lg">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-white">SEA ICE & DAYLIGHT</span><br/>
                    <span class="text-white">THE DEADLY CORRELATION</span>
                </h2>
                <p class="text-xl text-blue-200/80 max-w-3xl mx-auto mt-4">
                    As daylight increases, sea ice melts. This chart shows the inverse relationship that threatens polar bear survival. Hover over data points to see exact values.
                </p>
            </div>
            
            <div id="ice-daylight-chart" class="bg-black/40 backdrop-blur-md rounded-2xl p-6 md:p-8 border border-white/20 fade-in">
                <div class="flex flex-wrap justify-center gap-6 mb-6">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-blue-400 rounded"></div>
                        <span class="text-blue-200 text-sm font-semibold">Sea Ice (%)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-400 rounded"></div>
                        <span class="text-yellow-200 text-sm font-semibold">Daylight Hours</span>
                    </div>
                </div>
                <svg id="chart-svg" class="w-full" style="height: 500px;" aria-label="Line chart showing sea ice percentage and daylight hours by month"></svg>
                <p class="text-xs text-blue-300/60 text-center mt-4">
                    Data source: MODIS Arctic data (2023), Utqiagvik, Alaska
                </p>
            </div>
            
            <!-- Engaging text block after chart -->
            <div class="mt-16 max-w-4xl mx-auto fade-in">
                <div class="bg-gradient-to-r from-blue-900/50 via-indigo-900/50 to-purple-900/50 backdrop-blur-sm rounded-2xl p-8 border-2 border-blue-500/30 shadow-2xl">
                    <div class="flex items-start gap-4 mb-4">
                        <div class="text-4xl">‚ùÑÔ∏è</div>
                        <div class="flex-1">
                            <h3 class="text-2xl font-black text-white mb-3 bg-gradient-to-r from-blue-300 to-cyan-300 bg-clip-text text-transparent">
                                The Invisible Countdown
                            </h3>
                            <p class="text-lg leading-relaxed text-blue-100 mb-4">
                                Every year, polar bears face a race against time. As you scroll through the 24 hour cycle above, you're witnessing the same transformation that happens over months in the Arctic. The sun rises, stays up longer, and the ice beneath their paws begins to disappear.
                            </p>
                            <p class="text-base leading-relaxed text-blue-200/90">
                                <strong class="text-yellow-300">The chart reveals a cruel irony:</strong> The more daylight there is, the more time they have to hunt, but the less ice there is to hunt on. By June, when the sun never sets, the ice has melted to dangerous lows. The bears' greatest hunting opportunity coincides with the disappearance of their hunting platform.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section id="facts-section" class="section bg-gradient-to-b from-indigo-900 via-blue-900 to-gray-900 py-20 px-6 min-h-screen relative overflow-hidden">
        <!-- Animated background elements -->
        <div class="absolute inset-0 opacity-20">
            <div class="absolute top-10 left-10 w-72 h-72 bg-blue-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-10 right-10 w-96 h-96 bg-indigo-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1.5s;"></div>
        </div>

        <div class="max-w-6xl mx-auto relative z-10">
            <div class="text-center mb-16 fade-in">
                <h2 class="text-5xl md:text-7xl font-black tracking-tighter mb-6 drop-shadow-2xl">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-300 via-indigo-300 to-white animate-pulse">SEASONAL</span><br/>
                    <span class="text-white">FACTS & BEHAVIORS</span>
                </h2>
                <p class="text-xl text-blue-200/90 max-w-3xl mx-auto leading-relaxed">
                    Discover how polar bears adapt to changing daylight throughout the seasons.
                </p>
            </div>

            <div id="seasonal-facts-container"></div>
        </div>
    </section>

    <section id="seasonal-comparison-section" class="section bg-gradient-to-b from-gray-900 via-indigo-900 to-gray-900 py-20 px-6 min-h-screen flex items-center justify-center relative overflow-hidden">
        <!-- Animated background -->
        <div class="absolute inset-0 opacity-20">
            <div class="absolute top-20 left-20 w-96 h-96 bg-indigo-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-20 right-20 w-96 h-96 bg-purple-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1s;"></div>
        </div>
        
        <div class="max-w-6xl mx-auto relative z-10 w-full">
            <div class="text-center mb-12 fade-in">
                <h2 class="text-4xl md:text-6xl font-black tracking-tighter mb-4 drop-shadow-lg">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-indigo-300 via-purple-300 to-pink-300">SEASONAL COMPARISON</span>
                </h2>
                <p class="text-xl text-blue-200/80 max-w-3xl mx-auto mt-4">
                    Compare how sea ice and daylight vary across seasons. Summer's combination of maximum daylight and minimum ice creates the perfect storm. Click on seasons to highlight and compare values.
                </p>
            </div>
            
            <!-- Engaging text block before chart -->
            <div class="mb-12 max-w-4xl mx-auto fade-in">
                <div class="bg-gradient-to-r from-red-900/40 via-orange-900/30 to-yellow-900/30 backdrop-blur-sm rounded-2xl p-8 border-2 border-red-500/30 shadow-2xl">
                    <div class="flex items-start gap-4">
                        <div class="text-4xl">üî•</div>
                        <div class="flex-1">
                            <h3 class="text-2xl font-black text-white mb-3 bg-gradient-to-r from-red-300 to-orange-300 bg-clip-text text-transparent">
                                The Summer Death Sentence
                            </h3>
                            <p class="text-lg leading-relaxed text-red-100 mb-3">
                                Look at the chart below. Notice how Summer stands out, not just in color, but in danger. While other seasons offer a balance, summer delivers a double blow: <strong class="text-yellow-300">maximum daylight (24 hours) with minimum ice (often below 30%)</strong>.
                            </p>
                            <p class="text-base leading-relaxed text-red-200/90">
                                This isn't just data. This is the difference between life and death. A polar bear can survive the polar night because the ice remains. But in summer, when the ice melts, they're stranded on land with no way to reach their prey. The longer the ice-free period, the more bears starve.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="seasonal-comparison-chart" class="bg-black/40 backdrop-blur-md rounded-2xl p-6 md:p-8 border border-white/20 fade-in">
                <div class="flex flex-wrap justify-center gap-6 mb-6">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-blue-400 rounded"></div>
                        <span class="text-blue-200 text-sm">Sea Ice (%)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-400 rounded"></div>
                        <span class="text-yellow-200 text-sm">Daylight Hours</span>
                    </div>
                </div>
                <svg id="seasonal-svg" class="w-full" style="height: 600px;" aria-label="Grouped bar chart comparing sea ice percentage and daylight hours across seasons"></svg>
                <p class="text-xs text-indigo-300/60 text-center mt-4">
                    Data source: MODIS Arctic data (2023), Utqiagvik, Alaska
                </p>
            </div>
            
            <!-- Engaging text block after chart -->
            <div class="mt-12 max-w-4xl mx-auto fade-in">
                <div class="bg-gradient-to-r from-indigo-900/50 via-purple-900/50 to-pink-900/50 backdrop-blur-sm rounded-2xl p-8 border-2 border-indigo-500/30 shadow-2xl">
                    <div class="flex items-start gap-4">
                        <div class="text-4xl">üìä</div>
                        <div class="flex-1">
                            <h3 class="text-2xl font-black text-white mb-3 bg-gradient-to-r from-indigo-300 to-purple-300 bg-clip-text text-transparent">
                                What the Numbers Don't Show
                            </h3>
                            <p class="text-lg leading-relaxed text-indigo-100 mb-3">
                                The bars you see represent averages, but climate change is making each summer worse. The ice-free season is starting earlier and ending later. What used to be a few weeks of fasting is now stretching to months.
                            </p>
                            <p class="text-base leading-relaxed text-indigo-200/90">
                                <strong class="text-purple-300">Click on different seasons</strong> to see the contrast. Notice how Winter and Spring offer hope, plenty of ice for hunting. But Summer? It's a death trap disguised as endless daylight. The bears can see their prey, but they can't reach it. The ice that should be their bridge has become open water.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section id="interactive-calculator-section" class="section bg-gradient-to-b from-indigo-900 via-purple-900 to-gray-900 py-12 px-6 flex items-center justify-center relative overflow-hidden">
        <!-- Animated background -->
        <div class="absolute inset-0 opacity-20">
            <div class="absolute top-20 left-20 w-96 h-96 bg-purple-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-20 right-20 w-96 h-96 bg-pink-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1s;"></div>
        </div>
        
        <div class="max-w-5xl mx-auto relative z-10 w-full">
            <div class="text-center mb-8 fade-in">
                <h2 class="text-3xl md:text-5xl font-black tracking-tighter mb-3 drop-shadow-lg">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-purple-300 via-pink-300 to-orange-300">SURVIVAL IMPACT CALCULATOR</span>
                </h2>
                <p class="text-lg text-purple-200/80 max-w-3xl mx-auto">
                    Explore how different conditions affect polar bear survival. Adjust the parameters below to see the real impact.
                </p>
            </div>
            
            <div class="bg-black/40 backdrop-blur-md rounded-2xl p-6 md:p-8 border-2 border-purple-500/30 shadow-2xl fade-in">
                <div class="grid md:grid-cols-2 gap-6">
                    <!-- Left Column: Inputs -->
                    <div class="space-y-4">
                        <div>
                            <label class="block text-purple-200 font-semibold mb-2 text-base">
                                Sea Ice Coverage (%)
                            </label>
                            <input 
                                type="range" 
                                id="ice-slider" 
                                min="0" 
                                max="100" 
                                value="50" 
                                class="w-full h-3 bg-purple-900/50 rounded-lg appearance-none cursor-pointer accent-purple-500 slider-custom"
                            />
                            <div class="flex justify-between mt-1.5">
                                <span class="text-purple-300 text-xs">0%</span>
                                <span id="ice-value" class="text-white font-bold text-lg">50%</span>
                                <span class="text-purple-300 text-xs">100%</span>
                            </div>
                            <p class="text-purple-300/70 text-xs mt-1">Lower ice = less hunting opportunity</p>
                        </div>
                        
                        <div>
                            <label class="block text-purple-200 font-semibold mb-2 text-base">
                                Fasting Duration (days)
                            </label>
                            <input 
                                type="range" 
                                id="fasting-slider" 
                                min="0" 
                                max="180" 
                                value="90" 
                                step="10"
                                class="w-full h-3 bg-purple-900/50 rounded-lg appearance-none cursor-pointer accent-orange-500 slider-custom"
                            />
                            <div class="flex justify-between mt-1.5">
                                <span class="text-purple-300 text-xs">0 days</span>
                                <span id="fasting-value" class="text-white font-bold text-lg">90 days</span>
                                <span class="text-purple-300 text-xs">180 days</span>
                            </div>
                            <p class="text-purple-300/70 text-xs mt-1">Days without food during ice-free period</p>
                        </div>
                        
                        <div>
                            <label class="block text-purple-200 font-semibold mb-2 text-base">
                                Starting Weight (lbs)
                            </label>
                            <input 
                                type="range" 
                                id="weight-slider" 
                                min="500" 
                                max="2000" 
                                value="1250" 
                                step="50"
                                class="w-full h-3 bg-purple-900/50 rounded-lg appearance-none cursor-pointer accent-blue-500 slider-custom"
                            />
                            <div class="flex justify-between mt-1.5">
                                <span class="text-purple-300 text-xs">500 lbs</span>
                                <span id="weight-value" class="text-white font-bold text-lg">1,250 lbs</span>
                                <span class="text-purple-300 text-xs">2,000 lbs</span>
                            </div>
                            <p class="text-purple-300/70 text-xs mt-1">Average adult male polar bear weight</p>
                        </div>
                    </div>
                    
                    <!-- Right Column: Results -->
                    <div class="space-y-3">
                        <div class="bg-gradient-to-br from-red-900/40 to-orange-900/30 rounded-xl p-4 border-2 border-red-500/50">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="text-2xl">‚öñÔ∏è</div>
                                <h3 class="text-lg font-black text-red-300">Weight Loss</h3>
                            </div>
                            <div class="text-3xl font-black text-white mb-1" id="weight-loss-display">180 lbs</div>
                            <p class="text-red-200/80 text-xs" id="weight-loss-percent">14.4% of body weight</p>
                            <div class="mt-3 h-2 bg-red-900/50 rounded-full overflow-hidden">
                                <div id="weight-loss-bar" class="h-full bg-gradient-to-r from-red-500 to-orange-500 transition-all duration-500" style="width: 14.4%"></div>
                            </div>
                        </div>
                        
                        <div class="bg-gradient-to-br from-yellow-900/40 to-orange-900/30 rounded-xl p-4 border-2 border-yellow-500/50">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="text-2xl">‚ö†Ô∏è</div>
                                <h3 class="text-lg font-black text-yellow-300">Survival Status</h3>
                            </div>
                            <div class="text-2xl font-black mb-1" id="survival-status">Vulnerable</div>
                            <p class="text-yellow-200/80 text-xs" id="survival-details">Moderate weight loss. Bear needs food soon.</p>
                        </div>
                        
                        <div class="bg-gradient-to-br from-blue-900/40 to-indigo-900/30 rounded-xl p-4 border-2 border-blue-500/50">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="text-2xl">üéØ</div>
                                <h3 class="text-lg font-black text-blue-300">Hunting Success</h3>
                            </div>
                            <div class="text-3xl font-black text-white mb-1" id="hunting-success">Moderate</div>
                            <p class="text-blue-200/80 text-xs" id="hunting-details">Some ice available. Limited hunting.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section id="quiz-section" class="section bg-gradient-to-b from-indigo-900 via-blue-900 to-gray-900 py-20 px-6 min-h-screen relative overflow-hidden">
        <!-- Animated background elements -->
        <div class="absolute inset-0 opacity-20">
            <div class="absolute top-10 left-10 w-72 h-72 bg-blue-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-10 right-10 w-96 h-96 bg-indigo-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1.5s;"></div>
        </div>

        <div class="max-w-6xl mx-auto relative z-10">
            <div class="text-center mb-16 fade-in">
                <h2 class="text-5xl md:text-7xl font-black tracking-tighter mb-6 drop-shadow-2xl">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-300 via-indigo-300 to-white">TEST YOUR</span><br/>
                    <span class="text-white">KNOWLEDGE</span>
                </h2>
                <p class="text-xl text-blue-200/90 max-w-3xl mx-auto leading-relaxed">
                    Based on what you've learned from the charts, facts, and calculator, test your understanding of how climate change affects polar bear survival.
                </p>
            </div>

            <div id="quiz-container" class="mb-16"></div>
        </div>
    </section>

    <section id="final-takeaway-section" class="section bg-gradient-to-b from-gray-900 via-slate-900 to-black py-12 px-6 flex items-center justify-center relative overflow-hidden min-h-screen">
        <!-- Animated background elements -->
        <div class="absolute inset-0 opacity-30">
            <div class="absolute top-20 left-20 w-96 h-96 bg-red-500 rounded-full blur-3xl animate-pulse"></div>
            <div class="absolute bottom-20 right-20 w-96 h-96 bg-blue-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 1s;"></div>
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-orange-500 rounded-full blur-3xl animate-pulse" style="animation-delay: 2s; opacity: 0.4;"></div>
        </div>
        
        <div class="max-w-6xl mx-auto relative z-10">
            <div class="takeaway-final fade-in">
                <div class="takeaway-icon">üå°Ô∏è</div>
                <h2>THE DEADLY PARADOX</h2>
                <p class="mb-3 text-sm">
                    The world's largest land predator, perfectly evolved for darkness and cold, faces its greatest threat not from the polar night, but from the endless summer sun. As daylight stretches to 24 hours, sea ice, the foundation of their existence, melts away, transforming their hunting grounds into open water.
                </p>
                <p class="text-base font-semibold text-yellow-300 mb-4">
                    The problem isn't the cold. It's the warmth that removes their platform for survival.
                </p>
                
                <div class="takeaway-stats">
                    <div class="takeaway-stat">
                        <div class="takeaway-stat-number">2 lbs</div>
                        <div class="takeaway-stat-label">Lost per day during summer fast</div>
                    </div>
                    <div class="takeaway-stat">
                        <div class="takeaway-stat-number">24h</div>
                        <div class="takeaway-stat-label">Continuous daylight in summer</div>
                    </div>
                    <div class="takeaway-stat">
                        <div class="takeaway-stat-number">70%</div>
                        <div class="takeaway-stat-label">Sea ice loss in peak summer</div>
                    </div>
                    <div class="takeaway-stat">
                        <div class="takeaway-stat-number">Months</div>
                        <div class="takeaway-stat-label">Extended ice-free season</div>
                    </div>
                </div>
                
                <div class="mt-4 pt-4 border-t border-white/20">
                    <p class="text-sm text-blue-200 italic mb-4">
                        "Addressing the length of the ice-free season is not just about conservation, it's about preventing the starvation of a species that has survived for millennia in Earth's harshest environment."
                    </p>
                    <p class="text-xs text-blue-300/50 text-center mt-6">
                        Data source: MODIS Arctic data (2023) | Research: Polar bear fasting behavior and sea ice dynamics
                    </p>
                </div>
                
            </div>
        </div>
    </section>
    

    <script>
        let ARCTIC_DATA = [];
        let LOCATIONS = [];
        const SEASONS = ["Spring", "Summer", "Fall", "Winter"];

        let state = {
            scrollProgress: 0,
            season: "Spring",
            location: "Utqiagvik, Alaska",
            currentTime: 0,
            currentSection: 'intro',
            hasReached24Hours: false, // Track if user has scrolled through full 24 hours
        };

        const QUIZ_QUESTIONS = [
            {
                question: "What does the line chart reveal about the relationship between daylight hours and sea ice?",
                options: ["They increase together", "They have an inverse relationship (as daylight increases, ice decreases)", "They are unrelated", "They both peak in winter"],
                correct: 1,
                explanation: "The charts show an inverse relationship: as daylight hours increase throughout the year, sea ice percentage decreases. This is the core problem - more daylight means more ice melting."
            },
            {
                question: "Why is summer particularly lethal for polar bears, even though they have 24 hours of daylight to hunt?",
                options: ["They get too hot in the sun", "The ice melts, removing their hunting platform", "Seals migrate away", "They can't see well in constant daylight"],
                correct: 1,
                explanation: "The problem isn't the cold or lack of daylight - it's that the ice melts away. Without ice, polar bears can't reach seals, even though they can see them. They're forced into a fasting period, losing up to 2 pounds per day."
            },
            {
                question: "What is the 'deadly paradox' mentioned in the visualization?",
                options: ["Polar bears are too large to survive", "The season with the most daylight (summer) is the most dangerous", "Polar bears can't swim", "Winter is too cold for survival"],
                correct: 1,
                explanation: "The deadly paradox is that summer brings 24 hours of daylight (maximum visibility for hunting) but also minimum sea ice (no platform to hunt from). The bears can see their prey but can't reach it - a cruel irony."
            }
        ];

        const GUESSING_GAMES = [
            {
                title: "Guess the Weight!",
                question: "How much can an adult male polar bear weigh?",
                answer: 1500,
                unit: "pounds",
                hint: "They're the largest land carnivores on Earth!",
                icon: "scale"
            },
            {
                title: "Guess the Distance!",
                question: "How far can a polar bear swim in one journey?",
                answer: 60,
                unit: "miles",
                hint: "They're excellent swimmers!",
                icon: "waves"
            },
        ];

        const SEASONAL_FACTS = {
            Winter: {
                daylightHours: "0-4 hours",
                description: "With minimal daylight, polar bears rely on their incredible adaptations to survive the darkest season.",
                facts: [
                    { title: "They Don't Hibernate!", content: "Unlike other bears, polar bears never hibernate. They remain active all winter, hunting seals at breathing holes in the ice even with almost no daylight.", icon: "moon", isReveal: true, daylightConnection: "Active during 0-4 hours of daylight" },
                    { title: "Superior Sense of Smell", content: "Polar bears can smell a seal from over a mile away, even through several feet of ice and snow. This sense becomes crucial when visibility is limited by darkness.", icon: "wind", daylightConnection: "Compensates for lack of daylight" },
                    { title: "Thick Blubber", content: "Polar bears have blubber up to 4.5 inches (11 cm) thick, which helps them stay warm in freezing Arctic temperatures during the long, dark winter months.", icon: "thermometer", daylightConnection: "Protection during extended darkness" }
                ]
            },
            Spring: {
                daylightHours: "11-21 hours",
                description: "As daylight returns, polar bears emerge from dens and begin their most active hunting season.",
                facts: [
                    { title: "Mating Season", content: "Spring is mating season for polar bears. With increasing daylight (11-21 hours), bears become more active and social. Females give birth to cubs in winter dens, usually to twins.", icon: "heart", daylightConnection: "Increased activity with more daylight" },
                    { title: "Whale Hunting", content: "In spring, polar bears sometimes hunt whales that get trapped in ice cracks, providing a valuable food source. The longer daylight hours give them more time to hunt.", icon: "waves", daylightConnection: "More hunting time with extended daylight" },
                    { title: "Return to Shorelines", content: "As ice begins to break and daylight increases, polar bears return closer to shorelines, following the retreating ice edge where seals are more accessible.", icon: "flower", daylightConnection: "Following ice edge as daylight grows" }
                ]
            },
            Summer: {
                daylightHours: "24 hours",
                description: "The most dangerous season. With 24 hours of continuous daylight, melting ice, and rising temperatures, polar bears face their greatest threat to survival.",
                facts: [
                    { title: "The Lethal Fasting Period", content: "When sea ice melts in summer, polar bears lose their hunting platform. They enter a dangerous fasting period, losing up to 2 pounds per day. Many bears don't survive until the ice returns in fall.", icon: "sun", isReveal: true, daylightConnection: "24-hour daylight = no ice = no food" },
                    { title: "Melting Ice Sheets", content: "Rising temperatures cause sea ice to melt, destroying the platform polar bears need to hunt seals. Without ice, they're forced to swim longer distances, expending precious energy they can't replace.", icon: "thermometer", isReveal: true, daylightConnection: "Warmer temperatures melt essential hunting grounds" },
                    { title: "Energy Depletion", content: "Polar bears can swim for days, but in summer they're swimming to survive, not to hunt. Each long-distance swim burns critical fat reserves. Starvation becomes a real threat.", icon: "waves", daylightConnection: "Swimming without food depletes energy stores" }
                ]
            },
            Fall: {
                daylightHours: "8-12 hours",
                description: "As daylight decreases, polar bears prepare for winter by building dens and teaching young cubs essential skills.",
                facts: [
                    { title: "Play Fighting", content: "Young polar bears play fight to learn essential hunting and survival skills they'll need as adults. With decreasing daylight, they practice before the dark winter.", icon: "zap", daylightConnection: "Learning before daylight fades" },
                    { title: "Den Building", content: "Pregnant females seek out denning areas to give birth in the upcoming winter. They need to find a suitable den before the continuous darkness sets in.", icon: "home", daylightConnection: "Seeking den before continuous darkness" },
                    { title: "Hyperphagia", content: "Polar bears enter a state of intense feeding, consuming large amounts of food (mostly seals) to build up fat reserves before the long, dark winter fasting period begins.", icon: "shovel", daylightConnection: "Hunting during shorter daylight hours" }
                ]
            }
        };


        // --- D3 MAP DRAWING FUNCTIONS (PLACEHOLDERS) ---
        const UTQIAGVIK_COORDINATES = [-156.6781, 71.3000]; // Longitude, Latitude

        function drawMap(worldData) {
            const svg = d3.select("#arctic-map");
            const width = 3600;
            const height = 1800;

            const projection = d3.geoOrthographic()
                .rotate([-UTQIAGVIK_COORDINATES[0], -UTQIAGVIK_COORDINATES[1], 0])
                .scale(1200)
                .translate([width / 2, height / 2])
                .clipAngle(90);

            const path = d3.geoPath().projection(projection);

            // Draw land
            d3.select("#world-map").selectAll("path")
                .data(topojson.feature(worldData, worldData.objects.countries).features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "#1e293b")
                .attr("stroke", "#334155")
                .attr("stroke-width", 2);

            // Draw the location marker (Dot for Utqiagvik)
            const marker = d3.select("#location-marker");
            const p = projection(UTQIAGVIK_COORDINATES);

            marker.append("circle")
                .attr("cx", p[0])
                .attr("cy", p[1])
                .attr("r", 20)
                .attr("fill", "red")
                .attr("opacity", 0)
                .transition()
                .duration(1000)
                .attr("opacity", 1);
            
            // Draw Arctic Circle
            const graticule = d3.geoGraticule();
            svg.append("path")
                .datum(graticule.lines())
                .attr("class", "graticule")
                .attr("d", path)
                .attr("fill", "none")
                .attr("stroke", "#3b82f6") // blue-500
                .attr("stroke-width", 4)
                .attr("stroke-dasharray", "20, 10")
                .attr("opacity", 0);

            svg.append("circle")
                .attr("cx", p[0])
                .attr("cy", p[1])
                .attr("r", 15)
                .attr("fill", "none")
                .attr("stroke", "white")
                .attr("stroke-width", 5)
                .attr("opacity", 0);


            // Function to handle map transition based on scroll
            window.updateMapProjection = (scrollProgress) => {
                const mapSectionHeight = document.getElementById('hook-section').offsetHeight;
                const scrollY = window.scrollY;

                // Stage 1: Zoom in on initial scroll (0% to 30%)
                if (scrollProgress < 0.30) {
                    const progress = scrollProgress / 0.30;
                    const scaleStart = 1200;
                    const scaleEnd = 3500;
                    const scale = scaleStart + (scaleEnd - scaleStart) * progress;

                    projection
                        .scale(scale)
                        .translate([width / 2, height / 2]);

                    d3.select("#world-map").selectAll("path").attr("d", path);

                    const markerP = projection(UTQIAGVIK_COORDINATES);
                    d3.select("#location-marker").select("circle")
                        .attr("cx", markerP[0])
                        .attr("cy", markerP[1]);

                    // Show first text, hide second text completely (prevent overlap)
                    d3.select("#map-text-overlay").style("opacity", 1).style("pointer-events", "auto");
                    d3.select("#map-blur-overlay").style("opacity", 0).style("pointer-events", "none");
                    d3.select("#map-title").text("WHERE IN THE ARCTIC?");
                } 
                // Stage 2: Fade out first text completely (30% to 40%)
                else if (scrollProgress >= 0.30 && scrollProgress < 0.40) {
                    projection.scale(3500);
                    d3.select("#world-map").selectAll("path").attr("d", path);
                    const markerP = projection(UTQIAGVIK_COORDINATES);
                    d3.select("#location-marker").select("circle")
                        .attr("cx", markerP[0])
                        .attr("cy", markerP[1]);

                    // Fade out first text completely before showing second (prevent overlap)
                    const fadeOutProgress = (scrollProgress - 0.30) / 0.10;
                    const firstTextOpacity = 1 - fadeOutProgress;
                    d3.select("#map-text-overlay").style("opacity", firstTextOpacity);
                    
                    // Only show second text when first is completely gone
                    if (firstTextOpacity <= 0.01) {
                        d3.select("#map-text-overlay").style("opacity", 0).style("pointer-events", "none");
                        d3.select("#map-blur-overlay").style("opacity", 0).style("pointer-events", "none");
                    } else {
                        d3.select("#map-blur-overlay").style("opacity", 0).style("pointer-events", "none");
                    }
                } 
                // Stage 3: Fade in second text (40% to 50%)
                else if (scrollProgress >= 0.40 && scrollProgress < 0.50) {
                    projection.scale(3500);
                    d3.select("#world-map").selectAll("path").attr("d", path);
                    const markerP = projection(UTQIAGVIK_COORDINATES);
                    d3.select("#location-marker").select("circle")
                        .attr("cx", markerP[0])
                        .attr("cy", markerP[1]);

                    // First text is now completely hidden, fade in second text
                    d3.select("#map-text-overlay").style("opacity", 0).style("pointer-events", "none");
                    const fadeInProgress = (scrollProgress - 0.40) / 0.10;
                    d3.select("#map-blur-overlay").style("opacity", fadeInProgress).style("pointer-events", fadeInProgress > 0.01 ? "auto" : "none");
                } 
                // Stage 4: Hold second text visible (50% to 75%)
                else if (scrollProgress >= 0.50 && scrollProgress < 0.75) {
                    projection.scale(3500);
                    d3.select("#world-map").selectAll("path").attr("d", path);
                    const markerP = projection(UTQIAGVIK_COORDINATES);
                    d3.select("#location-marker").select("circle")
                        .attr("cx", markerP[0])
                        .attr("cy", markerP[1]);

                    // Keep second text fully visible, first text hidden (prevent overlap)
                    d3.select("#map-text-overlay").style("opacity", 0).style("pointer-events", "none");
                    d3.select("#map-blur-overlay").style("opacity", 1).style("pointer-events", "auto");
                } 
                // Stage 5: Fade out map and fade in visualization (75% to 100%)
                else {
                    projection.scale(3500);
                    d3.select("#world-map").selectAll("path").attr("d", path);
                    const markerP = projection(UTQIAGVIK_COORDINATES);
                    d3.select("#location-marker").select("circle")
                        .attr("cx", markerP[0])
                        .attr("cy", markerP[1]);
                    
                    const fadeProgress = (scrollProgress - 0.75) / 0.25;
                    const mapOpacity = Math.max(0, 1 - fadeProgress);
                    const visOpacity = Math.min(1, fadeProgress);
                    
                    d3.select("#map-container").style("opacity", mapOpacity);
                    // Ensure texts don't overlap - hide both when map fades
                    d3.select("#map-text-overlay").style("opacity", 0).style("pointer-events", "none");
                    d3.select("#map-blur-overlay").style("opacity", mapOpacity).style("pointer-events", mapOpacity > 0.01 ? "auto" : "none");
                    
                    // Start showing visualization as map fades
                    const appContainer = document.getElementById("app-container");
                    if(appContainer) {
                        appContainer.style.opacity = visOpacity;
                    }
                }
            };
        }

        // --- VISUALIZATION/APP FUNCTIONS (PLACEHOLDERS) ---
        // --- D3 GAUGE SETUP AND UPDATE ---

const setupGauge = (id, color) => {
    const w = 64, h = 64;
    const svg = d3.select(id).html("").append("svg")
        .attr("width", w).attr("height", h)
        .append("g").attr("transform", `translate(${w/2},${h/2})`);
    svg.append("path").attr("d", d3.arc().innerRadius(20).outerRadius(28).startAngle(0).endAngle(2*Math.PI))
        .attr("fill", "rgba(255,255,255,0.1)");
    const arcFg = d3.arc().innerRadius(20).outerRadius(28).cornerRadius(5);
    const path = svg.append("path").datum({endAngle:0}).attr("fill", color).attr("d", arcFg);
    return { path, arcFg };
};

// Initialize the specific gauges globally (MUST run after D3 loads)
const brightGauge = setupGauge("#vis-brightness","#fbbf24");
const cloudGauge = setupGauge("#vis-cloud","#60a5fa");

const updateGauge = (g,v,m) => {
    const a = (v/m)*2*Math.PI;
    g.path.transition().duration(500).attrTween("d",function(d){
        const i = d3.interpolate(d.endAngle,a);
        return t => { d.endAngle=i(t); return g.arcFg(d); };
    });
};

// --- DATA & COLOR LOGIC ---

function getSeasonStats(site, season){
    // CRITICAL CHECK: ARCTIC_DATA must contain records
    if(!ARCTIC_DATA || ARCTIC_DATA.length === 0) return {brightness: 0, cloud: 0, daylight: 0};
    
    const d = ARCTIC_DATA.filter(x => x.site === site && x.season === season);
    if(!d.length) return {brightness: 0, cloud: 0, daylight: 0};
    
    const avg = f => Math.round(d.reduce((s, x) => s + x[f], 0) / d.length * 10) / 10;
    
    return {
        brightness: avg('brightnessIndex'), 
        cloud: avg('cloudCover'), 
        daylight: avg('daylightHours')
    };
}

function getSkyColor(t, season){
    // t is state.currentTime (float hour 0-24)
    if(season === "Winter"){
        const d = Math.abs(12 - t); 
        return `hsl(220, 60%, ${Math.max(5, 20 - d * 2)}%)`;
    }
    
    if(season === "Summer"){
        const d = Math.abs(12 - t); 
        return `hsl(190, 80%, ${Math.max(40, 80 - d * 2)}%)`;
    }
    
    if(t < 5 || t > 19) return "hsl(220, 80%, 10%)";
    if(t < 7 || t > 17) return "hsl(20, 70%, 60%)";
    
    return "hsl(195, 90%, 70%)";
}

// --- MAIN RENDER LOOP (The Core Visualization Logic) ---

function render(){
    // If data hasn't loaded yet, exit gracefully
    if(!ARCTIC_DATA.length) return;

    // 1. Get static seasonal averages
    const stats = getSeasonStats(state.location, state.season);
    
    // 2. Update Gauges and Display Text
    updateGauge(brightGauge, stats.brightness, 100); 
    updateGauge(cloudGauge, stats.cloud, 100); 

    document.getElementById("val-brightness").innerText = stats.brightness;
    document.getElementById("val-cloud").innerText = stats.cloud + "%";
    document.getElementById("val-daylight").innerText = stats.daylight + "h";

    const t = state.currentTime; // Float hour (0 to 24)

    // 3. Update Sky Background Color
    document.getElementById("app-container").style.backgroundColor = getSkyColor(t, state.season);

    // 4. Celestial Body Rotation
    const rot = (t / 24) * 360 - 90; 
    const sun = document.getElementById("celestial-body");
    
    sun.style.opacity = stats.daylight < 1 ? 0.2 : 1;
    sun.style.transform = `rotate(${rot}deg)`;

    // 5. Update Clouds Density and Stars (Assumes functions are defined)
    if (typeof updateCloudsDensity === 'function') updateCloudsDensity(stats.cloud);
    const h = Math.floor(t);
    if (typeof updateStars === 'function') updateStars(h, state.season);

    // 6. Time Display Update
    const m = Math.floor((t - h) * 60);
    document.getElementById("time-display").innerText =
        `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

// --- TIME & PROGRESS DISPLAY (Used by handleScroll) ---

function updateYearProgress(){
    const el = document.getElementById("year-season");
    if(state.currentSection === 'visualization'){
        const h = Math.floor(state.currentTime);
        const m = Math.floor((state.currentTime % 1) * 60); 
        el.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
    } else {
        el.textContent = state.season;
    }
}

function updateYearProgressBar(p){
    document.getElementById("year-progress-bar").style.width = `${p * 100}%`;
}

function updateTimeCycle(progress) {
    // 1. Convert scroll progress (0 to 1) to float hours (0 to 24)
    const timeFloat = progress * 24; 
    
    // 2. Update the global state
    state.currentTime = timeFloat; 
    
    // 3. Update the progress bar display
    updateYearProgressBar(progress);
    
    // 4. Call the central render function
    render(); 
}

// --- CHART FUNCTIONS ---
function createIceDaylightChart() {
    if(!ARCTIC_DATA || ARCTIC_DATA.length === 0) {
        console.warn("No data available for chart");
        return;
    }
    
    const svg = d3.select("#chart-svg");
    svg.selectAll("*").remove(); // Clear any existing chart
    
    const margin = {top: 80, right: 80, bottom: 120, left: 80};
    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;
    
    // Group data by month and calculate averages
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    
    // Get Utqiagvik data or fallback to all data
    const utqiagvikData = ARCTIC_DATA.filter(d => d.site === "Utqiagvik, Alaska");
    const dataToUse = utqiagvikData.length > 0 ? utqiagvikData : ARCTIC_DATA;
    
    // Group by month (assuming data is roughly chronological, 30 days per month)
    const monthlyData = [];
    const recordsPerMonth = Math.ceil(dataToUse.length / 12);
    
    for(let month = 0; month < 12; month++) {
        const startIdx = month * recordsPerMonth;
        const endIdx = Math.min(startIdx + recordsPerMonth, dataToUse.length);
        const monthRecords = dataToUse.slice(startIdx, endIdx);
        
        if(monthRecords.length > 0) {
            const avgSeaIce = monthRecords.reduce((sum, d) => sum + (d.seaIce || 0), 0) / monthRecords.length;
            const avgDaylight = monthRecords.reduce((sum, d) => sum + (d.daylightHours || 0), 0) / monthRecords.length;
            
            monthlyData.push({
                month: month,
                monthName: monthNames[month],
                seaIce: Math.round(avgSeaIce * 10) / 10,
                daylightHours: Math.round(avgDaylight * 10) / 10,
                season: monthRecords[0].season || "Unknown"
            });
        }
    }
    
    // Create scales
    const xScale = d3.scaleBand()
        .domain(monthlyData.map(d => d.monthName))
        .range([0, width])
        .padding(0.2);
    
    const yScaleIce = d3.scaleLinear()
        .domain([0, 100])
        .nice()
        .range([height, 0]);
    
    const yScaleDaylight = d3.scaleLinear()
        .domain([0, 24])
        .nice()
        .range([height, 0]);
    
    // Create line generators
    const iceLine = d3.line()
        .x(d => xScale(d.monthName) + xScale.bandwidth() / 2)
        .y(d => yScaleIce(d.seaIce))
        .curve(d3.curveMonotoneX);
    
    const daylightLine = d3.line()
        .x(d => xScale(d.monthName) + xScale.bandwidth() / 2)
        .y(d => yScaleDaylight(d.daylightHours))
        .curve(d3.curveMonotoneX);
    
    // Create groups
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Add grid lines
    const gridLines = g.append("g").attr("class", "grid");
    gridLines.selectAll("line.horizontal")
        .data(yScaleIce.ticks(5))
        .enter().append("line")
        .attr("class", "horizontal")
        .attr("x1", 0)
        .attr("x2", width)
        .attr("y1", d => yScaleIce(d))
        .attr("y2", d => yScaleIce(d))
        .attr("stroke", "rgba(255,255,255,0.1)")
        .attr("stroke-width", 1);
    
    // Add axes
    const xAxis = d3.axisBottom(xScale)
        .tickSize(0);
    
    const yAxisIce = d3.axisLeft(yScaleIce)
        .ticks(5)
        .tickFormat(d => `${d}%`);
    
    const yAxisDaylight = d3.axisRight(yScaleDaylight)
        .ticks(6)
        .tickFormat(d => `${d}h`);
    
    g.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#94a3b8")
        .style("font-size", "14px")
        .style("font-weight", "600");
    
    g.append("g")
        .call(yAxisIce)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#60a5fa")
        .style("font-size", "13px");
    
    g.append("g")
        .attr("transform", `translate(${width},0)`)
        .call(yAxisDaylight)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#fbbf24")
        .style("font-size", "13px");
    
    // Add axis labels
    g.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -60)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .attr("fill", "#60a5fa")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Average Sea Ice (%)");
    
    g.append("text")
        .attr("transform", "rotate(90)")
        .attr("y", width + 60)
        .attr("x", height / 2)
        .attr("text-anchor", "middle")
        .attr("fill", "#fbbf24")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Average Daylight Hours");
    
    g.append("text")
        .attr("transform", `translate(${width/2},${height + 60})`)
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Month (2023)");
    
    // Add axes styling
    g.selectAll(".axis line, .axis path")
        .attr("stroke", "rgba(255,255,255,0.3)")
        .attr("stroke-width", 1);
    
    // Add sea ice line (initially hidden, will animate on scroll)
    const icePath = g.append("path")
        .datum(monthlyData)
        .attr("fill", "none")
        .attr("stroke", "#60a5fa")
        .attr("stroke-width", 4)
        .attr("d", iceLine)
        .style("filter", "drop-shadow(0 0 8px rgba(96, 165, 250, 0.6))")
        .attr("stroke-dasharray", function() {
            const totalLength = this.getTotalLength();
            return totalLength + " " + totalLength;
        })
        .attr("stroke-dashoffset", function() {
            return this.getTotalLength();
        })
        .attr("class", "ice-line-path");
    
    // Add daylight line (initially hidden, will animate on scroll)
    const daylightPath = g.append("path")
        .datum(monthlyData)
        .attr("fill", "none")
        .attr("stroke", "#fbbf24")
        .attr("stroke-width", 4)
        .attr("d", daylightLine)
        .style("filter", "drop-shadow(0 0 8px rgba(251, 191, 36, 0.6))")
        .attr("stroke-dasharray", function() {
            const totalLength = this.getTotalLength();
            return totalLength + " " + totalLength;
        })
        .attr("stroke-dashoffset", function() {
            return this.getTotalLength();
        })
        .attr("class", "daylight-line-path");
    
    // Store paths for animation
    window.iceLinePath = icePath;
    window.daylightLinePath = daylightPath;
    
    // Ensure lines start completely hidden
    setTimeout(() => {
        if (window.iceLinePath && window.daylightLinePath) {
            const iceNode = window.iceLinePath.node();
            const daylightNode = window.daylightLinePath.node();
            if (iceNode) {
                const iceTotal = iceNode.getTotalLength();
                window.iceLinePath.attr("stroke-dashoffset", iceTotal);
            }
            if (daylightNode) {
                const daylightTotal = daylightNode.getTotalLength();
                window.daylightLinePath.attr("stroke-dashoffset", daylightTotal);
            }
        }
    }, 100);
    
    // Add dots for data points (initially hidden, will fade in with line)
    const iceDots = g.selectAll(".ice-dot")
        .data(monthlyData)
        .enter().append("circle")
        .attr("class", "ice-dot")
        .attr("cx", d => xScale(d.monthName) + xScale.bandwidth() / 2)
        .attr("cy", d => yScaleIce(d.seaIce))
        .attr("r", 0)
        .attr("fill", "#60a5fa")
        .attr("opacity", 0)
        .style("filter", "drop-shadow(0 0 4px rgba(96, 165, 250, 0.8))");
    
    const daylightDots = g.selectAll(".daylight-dot")
        .data(monthlyData)
        .enter().append("circle")
        .attr("class", "daylight-dot")
        .attr("cx", d => xScale(d.monthName) + xScale.bandwidth() / 2)
        .attr("cy", d => yScaleDaylight(d.daylightHours))
        .attr("r", 0)
        .attr("fill", "#fbbf24")
        .attr("opacity", 0)
        .style("filter", "drop-shadow(0 0 4px rgba(251, 191, 36, 0.8))");
    
    // Store dots for animation
    window.iceDots = iceDots;
    window.daylightDots = daylightDots;
    
    // Add tooltip
    const tooltip = d3.select("body").append("div")
        .attr("class", "chart-tooltip")
        .style("opacity", 0)
        .style("position", "absolute")
        .style("background", "rgba(0,0,0,0.9)")
        .style("backdrop-filter", "blur(10px)")
        .style("color", "white")
        .style("padding", "12px 16px")
        .style("border-radius", "8px")
        .style("border", "1px solid rgba(255,255,255,0.2)")
        .style("pointer-events", "none")
        .style("font-size", "13px")
        .style("z-index", "1000")
        .style("box-shadow", "0 10px 30px rgba(0,0,0,0.5)");
    
    // Add key annotations pointing out important findings - positioned to avoid overlaps
    const summerMonth = monthlyData.find(d => d.monthName === "Jun" || d.monthName === "Jul");
    const winterMonth = monthlyData.find(d => d.monthName === "Dec" || d.monthName === "Jan");
    
    if(summerMonth) {
        // Annotate summer - peak danger (position at top to avoid legend/axes)
        const summerX = xScale(summerMonth.monthName) + xScale.bandwidth() / 2;
        const summerIceY = yScaleIce(summerMonth.seaIce);
        const summerDaylightY = yScaleDaylight(summerMonth.daylightHours);
        
        // Position annotation at top of chart area, well above any data points
        const annotationY = -45; // Above chart area, below axis labels
        
        const annotationGroup = g.append("g").attr("class", "summer-annotation");
        
        // Line from data point to annotation
        annotationGroup.append("line")
            .attr("x1", summerX)
            .attr("x2", summerX)
            .attr("y1", Math.min(summerIceY, summerDaylightY) - 5)
            .attr("y2", annotationY + 15)
            .attr("stroke", "#ef4444")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "4,4")
            .style("opacity", 0)
            .transition()
            .duration(1000)
            .delay(2500)
            .style("opacity", 0.8);
        
        // Background box for text
        annotationGroup.append("rect")
            .attr("x", summerX - 110)
            .attr("y", annotationY - 12)
            .attr("width", 220)
            .attr("height", 24)
            .attr("fill", "rgba(15, 23, 42, 0.95)")
            .attr("stroke", "#ef4444")
            .attr("stroke-width", 1.5)
            .attr("rx", 4)
            .attr("opacity", 0)
            .transition()
            .duration(600)
            .delay(2500)
            .attr("opacity", 1);
        
        annotationGroup.append("text")
            .attr("x", summerX)
            .attr("y", annotationY + 4)
            .attr("text-anchor", "middle")
            .attr("fill", "#ef4444")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text("‚ö†Ô∏è Peak Danger: Max Daylight, Min Ice")
            .transition()
            .duration(800)
            .delay(2700)
            .style("opacity", 1);
    }
    
    if(winterMonth) {
        // Annotate winter - safe period (position at bottom, below x-axis)
        const winterX = xScale(winterMonth.monthName) + xScale.bandwidth() / 2;
        const winterIceY = yScaleIce(winterMonth.seaIce);
        const winterDaylightY = yScaleDaylight(winterMonth.daylightHours);
        
        // Position annotation below chart area, well below x-axis
        const annotationY = height + 50; // Below x-axis labels
        
        const annotationGroup = g.append("g").attr("class", "winter-annotation");
        
        // Line from data point to annotation
        annotationGroup.append("line")
            .attr("x1", winterX)
            .attr("x2", winterX)
            .attr("y1", Math.max(winterIceY, winterDaylightY) + 5)
            .attr("y2", annotationY - 15)
            .attr("stroke", "#60a5fa")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "4,4")
            .style("opacity", 0)
            .transition()
            .duration(1000)
            .delay(3000)
            .style("opacity", 0.8);
        
        // Background box for text
        annotationGroup.append("rect")
            .attr("x", winterX - 100)
            .attr("y", annotationY - 12)
            .attr("width", 200)
            .attr("height", 24)
            .attr("fill", "rgba(15, 23, 42, 0.95)")
            .attr("stroke", "#60a5fa")
            .attr("stroke-width", 1.5)
            .attr("rx", 4)
            .attr("opacity", 0)
            .transition()
            .duration(600)
            .delay(3000)
            .attr("opacity", 1);
        
        annotationGroup.append("text")
            .attr("x", winterX)
            .attr("y", annotationY + 4)
            .attr("text-anchor", "middle")
            .attr("fill", "#60a5fa")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text("‚úì Safe: Max Ice, Min Daylight")
            .transition()
            .duration(800)
            .delay(3200)
            .style("opacity", 1);
    }
    
    // Add invisible overlay for interactivity
    const overlay = g.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "transparent")
        .on("mousemove", function(event) {
            const [x] = d3.pointer(event);
            const monthName = xScale.domain().find(d => {
                const pos = xScale(d) + xScale.bandwidth() / 2;
                return Math.abs(pos - x) < xScale.bandwidth() / 2;
            });
            
            if(monthName) {
                const dataPoint = monthlyData.find(d => d.monthName === monthName);
                if(dataPoint) {
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 15) + "px")
                        .html(`
                            <div class="font-bold text-lg mb-2">${dataPoint.monthName} 2023</div>
                            <div class="space-y-1">
                                <div class="flex items-center gap-2">
                                    <div class="w-3 h-3 rounded-full bg-blue-400"></div>
                                    <span>Sea Ice: <strong>${dataPoint.seaIce.toFixed(1)}%</strong></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-3 h-3 rounded-full bg-yellow-400"></div>
                                    <span>Daylight: <strong>${dataPoint.daylightHours.toFixed(1)}h</strong></span>
                                </div>
                                <div class="pt-2 mt-2 border-t border-white/20 text-xs text-blue-200">
                                    Season: ${dataPoint.season}
                                </div>
                            </div>
                        `);
                }
            }
        })
        .on("mouseout", function() {
            tooltip.style("opacity", 0);
        });
}

// --- SEASONAL COMPARISON CHART (Grouped Bar Chart) ---
function createSeasonalComparisonChart() {
    if(!ARCTIC_DATA || ARCTIC_DATA.length === 0) {
        console.warn("No data available for seasonal comparison chart");
        return;
    }
    
    const svg = d3.select("#seasonal-svg");
    svg.selectAll("*").remove();
    
    const margin = {top: 80, right: 80, bottom: 120, left: 100};
    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
    const height = 600 - margin.top - margin.bottom;
    
    // Get data and calculate seasonal averages
    const utqiagvikData = ARCTIC_DATA.filter(d => d.site === "Utqiagvik, Alaska");
    const dataToUse = utqiagvikData.length > 0 ? utqiagvikData : ARCTIC_DATA;
    
    // Calculate averages by season
    const seasonalAverages = {};
    SEASONS.forEach(season => {
        const seasonData = dataToUse.filter(d => d.season === season);
        if(seasonData.length > 0) {
            const avgSeaIce = seasonData.reduce((sum, d) => sum + (d.seaIce || 0), 0) / seasonData.length;
            const avgDaylight = seasonData.reduce((sum, d) => sum + (d.daylightHours || 0), 0) / seasonData.length;
            const avgBrightness = seasonData.reduce((sum, d) => sum + (d.brightnessIndex || 0), 0) / seasonData.length;
            const avgCloud = seasonData.reduce((sum, d) => sum + (d.cloudCover || 0), 0) / seasonData.length;
            
            seasonalAverages[season] = {
                seaIce: Math.round(avgSeaIce * 10) / 10,
                daylightHours: Math.round(avgDaylight * 10) / 10,
                brightnessIndex: Math.round(avgBrightness * 10) / 10,
                cloudCover: Math.round(avgCloud * 10) / 10
            };
        }
    });
    
    // Prepare data for grouped bar chart
    const chartData = SEASONS.map(season => ({
        season: season,
        seaIce: seasonalAverages[season]?.seaIce || 0,
        daylightHours: seasonalAverages[season]?.daylightHours || 0
    }));
    
    // Create scales
    const xScale = d3.scaleBand()
        .domain(SEASONS)
        .range([0, width])
        .padding(0.3);
    
    const yScaleIce = d3.scaleLinear()
        .domain([0, 100])
        .nice()
        .range([height, 0]);
    
    const yScaleDaylight = d3.scaleLinear()
        .domain([0, 24])
        .nice()
        .range([height, 0]);
    
    // Color scheme
    const seasonColors = {
        "Winter": "#3b82f6",
        "Spring": "#22c55e",
        "Summer": "#ef4444",
        "Fall": "#f59e0b"
    };
    
    // Create groups
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Add grid lines
    const gridLines = g.append("g").attr("class", "grid");
    gridLines.selectAll("line.horizontal")
        .data(yScaleIce.ticks(5))
        .enter().append("line")
        .attr("class", "horizontal")
        .attr("x1", 0)
        .attr("x2", width)
        .attr("y1", d => yScaleIce(d))
        .attr("y2", d => yScaleIce(d))
        .attr("stroke", "rgba(255,255,255,0.1)")
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "4,4");
    
    // Add axes
    const xAxis = d3.axisBottom(xScale)
        .tickSize(0);
    
    const yAxisIce = d3.axisLeft(yScaleIce)
        .ticks(5)
        .tickFormat(d => `${d}%`);
    
    const yAxisDaylight = d3.axisRight(yScaleDaylight)
        .ticks(6)
        .tickFormat(d => `${d}h`);
    
    g.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#94a3b8")
        .style("font-size", "16px")
        .style("font-weight", "bold");
    
    g.append("g")
        .call(yAxisIce)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#60a5fa")
        .style("font-size", "13px");
    
    g.append("g")
        .attr("transform", `translate(${width},0)`)
        .call(yAxisDaylight)
        .attr("class", "axis")
        .selectAll("text")
        .attr("fill", "#fbbf24")
        .style("font-size", "13px");
    
    // Add axis labels
    g.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -70)
        .attr("x", -height / 2)
        .attr("text-anchor", "middle")
        .attr("fill", "#60a5fa")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Average Sea Ice (%)");
    
    g.append("text")
        .attr("transform", "rotate(90)")
        .attr("y", width + 70)
        .attr("x", height / 2)
        .attr("text-anchor", "middle")
        .attr("fill", "#fbbf24")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Average Daylight Hours");
    
    g.append("text")
        .attr("transform", `translate(${width/2},${height + 70})`)
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Season");
    
    // Add axes styling
    g.selectAll(".axis line, .axis path")
        .attr("stroke", "rgba(255,255,255,0.3)")
        .attr("stroke-width", 1);
    
    // Create grouped bars
    const barWidth = xScale.bandwidth() / 2;
    const barSpacing = barWidth * 0.2;
    
    // Sea Ice bars (left side of each group) - initially height 0, will animate on scroll
    // Use consistent blue color for all ice bars to avoid confusion
    const iceBars = g.selectAll(".ice-bar")
        .data(chartData)
        .enter().append("rect")
        .attr("class", "ice-bar")
        .attr("x", d => xScale(d.season) + barSpacing)
        .attr("y", height)
        .attr("width", barWidth - barSpacing)
        .attr("height", 0)
        .attr("fill", "#60a5fa") // Consistent blue for all ice bars
        .attr("opacity", 0.8)
        .style("filter", "drop-shadow(0 0 8px rgba(96, 165, 250, 0.6))");
    
    // Daylight bars (right side of each group) - initially height 0, will animate on scroll
    const daylightBars = g.selectAll(".daylight-bar")
        .data(chartData)
        .enter().append("rect")
        .attr("class", "daylight-bar")
        .attr("x", d => xScale(d.season) + barWidth)
        .attr("y", height)
        .attr("width", barWidth - barSpacing)
        .attr("height", 0)
        .attr("fill", "#fbbf24")
        .attr("opacity", 0.8)
        .style("filter", "drop-shadow(0 0 8px rgba(251, 191, 36, 0.6))");
    
    // Ensure bars start at height 0
    setTimeout(() => {
        if (window.seasonalIceBars) {
            window.seasonalIceBars.attr("height", 0).attr("y", height);
        }
        if (window.seasonalDaylightBars) {
            window.seasonalDaylightBars.attr("height", 0).attr("y", height);
        }
    }, 100);
    
    // Store bars for animation
    window.seasonalIceBars = iceBars;
    window.seasonalDaylightBars = daylightBars;
    window.seasonalChartData = chartData;
    window.seasonalYScaleIce = yScaleIce;
    window.seasonalYScaleDaylight = yScaleDaylight;
    window.seasonalHeight = height;
    window.seasonalBarWidth = barWidth;
    window.seasonalBarSpacing = barSpacing;
    
    // Add value labels on bars
    const iceLabels = g.selectAll(".ice-label")
        .data(chartData)
        .enter().append("text")
        .attr("class", "ice-label")
        .attr("x", d => xScale(d.season) + barWidth / 2 - barSpacing / 2)
        .attr("y", d => yScaleIce(d.seaIce) - 5)
        .attr("text-anchor", "middle")
        .attr("fill", "#e2e8f0")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .style("opacity", 0)
        .text(d => `${d.seaIce}%`)
        .each(function(d) { this.__data__ = d; }) // Store data for later access
        .transition()
        .duration(800)
        .delay((d, i) => i * 200 + 1000)
        .style("opacity", 1);
    
    const daylightLabels = g.selectAll(".daylight-label")
        .data(chartData)
        .enter().append("text")
        .attr("class", "daylight-label")
        .attr("x", d => xScale(d.season) + barWidth * 1.5 - barSpacing / 2)
        .attr("y", d => yScaleDaylight(d.daylightHours) - 5)
        .attr("text-anchor", "middle")
        .attr("fill", "#fbbf24")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .style("opacity", 0)
        .text(d => `${d.daylightHours}h`)
        .each(function(d) { this.__data__ = d; }) // Store data for later access
        .transition()
        .duration(800)
        .delay((d, i) => i * 200 + 1100)
        .style("opacity", 1);
    
    // Add legend
    const legend = g.append("g")
        .attr("transform", `translate(${width - 200}, 20)`);
    
    const legendData = [
        { label: "Sea Ice (%)", color: "#60a5fa", pattern: "solid" },
        { label: "Daylight (h)", color: "#fbbf24", pattern: "solid" }
    ];
    
    legend.selectAll(".legend-item")
        .data(legendData)
        .enter().append("g")
        .attr("class", "legend-item")
        .attr("transform", (d, i) => `translate(0, ${i * 25})`)
        .each(function(d) {
            const g = d3.select(this);
            g.append("rect")
                .attr("width", 20)
                .attr("height", 12)
                .attr("fill", d.color)
                .attr("rx", 2);
            g.append("text")
                .attr("x", 28)
                .attr("y", 9)
                .attr("fill", "#e2e8f0")
                .style("font-size", "13px")
                .text(d.label);
        });
    
    // Add tooltip
    const tooltip = d3.select("body").append("div")
        .attr("class", "chart-tooltip")
        .style("opacity", 0)
        .style("position", "absolute")
        .style("background", "rgba(0,0,0,0.9)")
        .style("backdrop-filter", "blur(10px)")
        .style("color", "white")
        .style("padding", "12px 16px")
        .style("border-radius", "8px")
        .style("border", "1px solid rgba(255,255,255,0.2)")
        .style("pointer-events", "none")
        .style("font-size", "13px")
        .style("z-index", "1000")
        .style("box-shadow", "0 10px 30px rgba(0,0,0,0.5)");
    
    // Interactive state
    let selectedSeason = null;
    let highlightedBars = { ice: null, daylight: null };
    
    // Add click handlers for season selection
    const seasonGroups = g.append("g").attr("class", "season-groups");
    
    // Add interactivity with click to highlight
    iceBars
        .style("cursor", "pointer")
        .on("click", function(event, d) {
            event.stopPropagation();
            // Toggle selection
            if(selectedSeason === d.season) {
                selectedSeason = null;
                // Reset all bars
                iceBars.attr("opacity", 0.8);
                daylightBars.attr("opacity", 0.8);
                iceLabels.style("opacity", 1);
                daylightLabels.style("opacity", 1);
            } else {
                selectedSeason = d.season;
                // Highlight selected season
                iceBars.attr("opacity", (bar) => bar.season === d.season ? 1 : 0.3);
                daylightBars.attr("opacity", (bar) => bar.season === d.season ? 1 : 0.3);
                iceLabels.each(function() {
                    const labelData = d3.select(this).datum();
                    d3.select(this).style("opacity", labelData && labelData.season === d.season ? 1 : 0.2);
                });
                daylightLabels.each(function() {
                    const labelData = d3.select(this).datum();
                    d3.select(this).style("opacity", labelData && labelData.season === d.season ? 1 : 0.2);
                });
            }
        })
        .on("mouseover", function(event, d) {
            if(selectedSeason && selectedSeason !== d.season) return;
            
            d3.select(this)
                .transition()
                .duration(150)
                .attr("opacity", 1)
                .attr("y", d => yScaleIce(d.seaIce) - 5)
                .attr("height", d => height - yScaleIce(d.seaIce) + 5)
                .attr("width", barWidth - barSpacing + 4);
            
            // Highlight corresponding daylight bar
            daylightBars.filter(bar => bar.season === d.season)
                .transition()
                .duration(150)
                .attr("opacity", 1)
                .attr("y", d => yScaleDaylight(d.daylightHours) - 5)
                .attr("height", d => height - yScaleDaylight(d.daylightHours) + 5)
                .attr("width", barWidth - barSpacing + 4);
            
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 15) + "px")
                .html(`
                    <div class="font-bold text-lg mb-2" style="color: ${seasonColors[d.season]}">${d.season}</div>
                    <div class="space-y-1">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded bg-blue-400"></div>
                            <span>Sea Ice: <strong>${d.seaIce}%</strong></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded bg-yellow-400"></div>
                            <span>Daylight: <strong>${d.daylightHours}h</strong></span>
                        </div>
                        <div class="mt-2 pt-2 border-t border-white/20 text-xs text-gray-300">
                            Click to compare with other seasons
                        </div>
                    </div>
                `);
        })
        .on("mouseout", function(event, d) {
            if(selectedSeason && selectedSeason !== d.season) return;
            
            d3.select(this)
                .transition()
                .duration(150)
                .attr("opacity", selectedSeason === d.season ? 1 : 0.8)
                .attr("y", d => yScaleIce(d.seaIce))
                .attr("height", d => height - yScaleIce(d.seaIce))
                .attr("width", barWidth - barSpacing);
            
            // Reset corresponding daylight bar
            daylightBars.filter(bar => bar.season === d.season)
                .transition()
                .duration(150)
                .attr("opacity", selectedSeason === d.season ? 1 : 0.8)
                .attr("y", d => yScaleDaylight(d.daylightHours))
                .attr("height", d => height - yScaleDaylight(d.daylightHours))
                .attr("width", barWidth - barSpacing);
            
            tooltip.style("opacity", 0);
        });
    
    daylightBars
        .style("cursor", "pointer")
        .on("click", function(event, d) {
            event.stopPropagation();
            // Toggle selection
            if(selectedSeason === d.season) {
                selectedSeason = null;
                // Reset all bars
                iceBars.attr("opacity", 0.8);
                daylightBars.attr("opacity", 0.8);
                iceLabels.style("opacity", 1);
                daylightLabels.style("opacity", 1);
            } else {
                selectedSeason = d.season;
                // Highlight selected season
                iceBars.attr("opacity", (bar) => bar.season === d.season ? 1 : 0.3);
                daylightBars.attr("opacity", (bar) => bar.season === d.season ? 1 : 0.3);
                iceLabels.each(function() {
                    const labelData = d3.select(this).datum();
                    d3.select(this).style("opacity", labelData && labelData.season === d.season ? 1 : 0.2);
                });
                daylightLabels.each(function() {
                    const labelData = d3.select(this).datum();
                    d3.select(this).style("opacity", labelData && labelData.season === d.season ? 1 : 0.2);
                });
            }
        })
        .on("mouseover", function(event, d) {
            if(selectedSeason && selectedSeason !== d.season) return;
            
            d3.select(this)
                .transition()
                .duration(150)
                .attr("opacity", 1)
                .attr("y", d => yScaleDaylight(d.daylightHours) - 5)
                .attr("height", d => height - yScaleDaylight(d.daylightHours) + 5)
                .attr("width", barWidth - barSpacing + 4);
            
            // Highlight corresponding ice bar
            iceBars.filter(bar => bar.season === d.season)
                .transition()
                .duration(150)
                .attr("opacity", 1)
                .attr("y", d => yScaleIce(d.seaIce) - 5)
                .attr("height", d => height - yScaleIce(d.seaIce) + 5)
                .attr("width", barWidth - barSpacing + 4);
            
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 15) + "px")
                .html(`
                    <div class="font-bold text-lg mb-2" style="color: ${seasonColors[d.season]}">${d.season}</div>
                    <div class="space-y-1">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded bg-blue-400"></div>
                            <span>Sea Ice: <strong>${d.seaIce}%</strong></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded bg-yellow-400"></div>
                            <span>Daylight: <strong>${d.daylightHours}h</strong></span>
                        </div>
                        <div class="mt-2 pt-2 border-t border-white/20 text-xs text-gray-300">
                            Click to compare with other seasons
                        </div>
                    </div>
                `);
        })
        .on("mouseout", function(event, d) {
            if(selectedSeason && selectedSeason !== d.season) return;
            
            d3.select(this)
                .transition()
                .duration(150)
                .attr("opacity", selectedSeason === d.season ? 1 : 0.8)
                .attr("y", d => yScaleDaylight(d.daylightHours))
                .attr("height", d => height - yScaleDaylight(d.daylightHours))
                .attr("width", barWidth - barSpacing);
            
            // Reset corresponding ice bar
            iceBars.filter(bar => bar.season === d.season)
                .transition()
                .duration(150)
                .attr("opacity", selectedSeason === d.season ? 1 : 0.8)
                .attr("y", d => yScaleIce(d.seaIce))
                .attr("height", d => height - yScaleIce(d.seaIce))
                .attr("width", barWidth - barSpacing);
            
            tooltip.style("opacity", 0);
        });
    
    // Click outside to deselect
    svg.on("click", function(event) {
        if(event.target === svg.node() || event.target.tagName === 'svg') {
            selectedSeason = null;
            iceBars.attr("opacity", 0.8);
            daylightBars.attr("opacity", 0.8);
            iceLabels.style("opacity", 1);
            daylightLabels.style("opacity", 1);
        }
    });
    
    // Highlight Summer as the most dangerous with detailed annotation - positioned to avoid overlaps
    const summerData = chartData.find(d => d.season === "Summer");
    if(summerData) {
        const summerX = xScale("Summer") + xScale.bandwidth() / 2;
        const summerIceY = yScaleIce(summerData.seaIce);
        const summerDaylightY = yScaleDaylight(summerData.daylightHours);
        
        // Highlight box (behind bars, won't overlap)
        g.append("rect")
            .attr("x", xScale("Summer") - 10)
            .attr("y", -10)
            .attr("width", xScale.bandwidth() + 20)
            .attr("height", height + 20)
            .attr("fill", "none")
            .attr("stroke", "#ef4444")
            .attr("stroke-width", 3)
            .attr("stroke-dasharray", "8,4")
            .attr("opacity", 0)
            .style("filter", "drop-shadow(0 0 15px rgba(239, 68, 68, 0.6))")
            .transition()
            .duration(1000)
            .delay(2000)
            .attr("opacity", 0.6);
        
        // Warning label at top (above chart, below axis labels)
        g.append("text")
            .attr("x", summerX)
            .attr("y", -25)
            .attr("text-anchor", "middle")
            .attr("fill", "#ef4444")
            .style("font-size", "13px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text("‚ö†Ô∏è Most Dangerous Season")
            .transition()
            .duration(800)
            .delay(2000)
            .style("opacity", 1);
        
        // Add annotation explaining why it's dangerous - positioned at top right to avoid overlaps
        const annotationBox = g.append("g").attr("class", "summer-danger-annotation");
        
        // Position annotation in top right corner, away from bars and axes
        const annotationX = width - 250;
        const annotationY = 20;
        
        annotationBox.append("rect")
            .attr("x", annotationX - 10)
            .attr("y", annotationY - 10)
            .attr("width", 240)
            .attr("height", 70)
            .attr("fill", "rgba(15, 23, 42, 0.95)")
            .attr("stroke", "#ef4444")
            .attr("stroke-width", 2)
            .attr("rx", 8)
            .attr("opacity", 0)
            .transition()
            .duration(800)
            .delay(3000)
            .attr("opacity", 1);
        
        annotationBox.append("text")
            .attr("x", annotationX + 110)
            .attr("y", annotationY + 15)
            .attr("text-anchor", "middle")
            .attr("fill", "#fbbf24")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text(`24h daylight = No darkness`)
            .transition()
            .duration(600)
            .delay(3200)
            .style("opacity", 1);
        
        annotationBox.append("text")
            .attr("x", annotationX + 110)
            .attr("y", annotationY + 35)
            .attr("text-anchor", "middle")
            .attr("fill", "#ef4444")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text(`${summerData.seaIce}% ice = No hunting platform`)
            .transition()
            .duration(600)
            .delay(3400)
            .style("opacity", 1);
        
        annotationBox.append("text")
            .attr("x", annotationX + 110)
            .attr("y", annotationY + 55)
            .attr("text-anchor", "middle")
            .attr("fill", "#fca5a5")
            .style("font-size", "11px")
            .style("opacity", 0)
            .text(`Result: Starvation & death`)
            .transition()
            .duration(600)
            .delay(3600)
            .style("opacity", 1);
        
        // Add arrow pointing from annotation to Summer bars
        annotationBox.append("line")
            .attr("x1", annotationX)
            .attr("x2", summerX)
            .attr("y1", annotationY + 30)
            .attr("y2", Math.min(summerIceY, summerDaylightY) - 10)
            .attr("stroke", "#ef4444")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrowhead-red)")
            .attr("opacity", 0)
            .transition()
            .duration(800)
            .delay(3000)
            .attr("opacity", 0.5);
        
        // Create arrowhead marker
        svg.append("defs").append("marker")
            .attr("id", "arrowhead-red")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 5)
            .attr("refY", 5)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("fill", "#ef4444");
    }
    
    // Add annotation for Winter (safe period) - positioned at bottom left
    const winterData = chartData.find(d => d.season === "Winter");
    if(winterData) {
        const winterX = xScale("Winter") + xScale.bandwidth() / 2;
        const winterIceY = yScaleIce(winterData.seaIce);
        
        const annotationBox = g.append("g").attr("class", "winter-safe-annotation");
        
        // Position at bottom left, below chart area
        const annotationX = 10;
        const annotationY = height + 50;
        
        annotationBox.append("rect")
            .attr("x", annotationX - 10)
            .attr("y", annotationY - 10)
            .attr("width", 200)
            .attr("height", 50)
            .attr("fill", "rgba(15, 23, 42, 0.95)")
            .attr("stroke", "#60a5fa")
            .attr("stroke-width", 2)
            .attr("rx", 8)
            .attr("opacity", 0)
            .transition()
            .duration(800)
            .delay(4000)
            .attr("opacity", 1);
        
        annotationBox.append("text")
            .attr("x", annotationX + 90)
            .attr("y", annotationY + 12)
            .attr("text-anchor", "middle")
            .attr("fill", "#60a5fa")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("opacity", 0)
            .text(`‚úì ${winterData.seaIce}% ice = Hunting platform`)
            .transition()
            .duration(600)
            .delay(4200)
            .style("opacity", 1);
        
        annotationBox.append("text")
            .attr("x", annotationX + 90)
            .attr("y", annotationY + 32)
            .attr("text-anchor", "middle")
            .attr("fill", "#94a3b8")
            .style("font-size", "11px")
            .style("opacity", 0)
            .text(`Safe period for polar bears`)
            .transition()
            .duration(600)
            .delay(4400)
            .style("opacity", 1);
        
        // Arrow pointing to Winter bars
        annotationBox.append("line")
            .attr("x1", annotationX + 200)
            .attr("x2", winterX)
            .attr("y1", annotationY + 20)
            .attr("y2", Math.max(winterIceY, yScaleDaylight(winterData.daylightHours)) + 5)
            .attr("stroke", "#60a5fa")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrowhead-blue)")
            .attr("opacity", 0)
            .transition()
            .duration(800)
            .delay(4000)
            .attr("opacity", 0.5);
        
        // Create blue arrowhead marker
        svg.append("defs").append("marker")
            .attr("id", "arrowhead-blue")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 5)
            .attr("refY", 5)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("fill", "#60a5fa");
    }
}

// --- UI AND INITIALIZATION FUNCTIONS ---

function updateSeasonButtons() {
    const btns=document.getElementById("season-controls").querySelectorAll("button");
    btns.forEach((b,i)=>{
        const s = SEASONS[i];
        b.className = `flex-1 py-1 px-2 text-xs rounded-md transition-colors ${
            s===state.season?'bg-white text-black font-bold':'text-white/60 hover:bg-white/10'
        }`;
    });
}

function updateLocationDisplay() {
    const t=document.getElementById("current-location-text");
    const d=document.getElementById("location-description");
    t.style.opacity=0; d.style.opacity=0;
    setTimeout(()=>{
        t.textContent=state.location;
        d.textContent="Polar Bear Territory";
        t.style.opacity=1; d.style.opacity=1;
    },200);
}

function initializeUI() {
    const c = document.getElementById("season-controls");
    c.innerHTML = '';
    
    // Create season buttons
    SEASONS.forEach(s=>{
        const b = document.createElement("button");
        b.className = `flex-1 py-1 px-2 text-xs rounded-md transition-colors ${
            s===state.season?'bg-white text-black font-bold':'text-white/60 hover:bg-white/10'
        }`;
        b.textContent=s;
        // Fix: Ensure render is called on click
        b.onclick=()=>{ state.season=s; updateSeasonButtons(); render(); };
        c.appendChild(b);
    });

    updateLocationDisplay();
    updateYearProgress();
    updateYearProgressBar(0);
    // Assuming these exist:
    if(typeof initializeQuizzes === 'function') initializeQuizzes();
    if(typeof initializeSeasonalFacts === 'function') initializeSeasonalFacts();

    document.getElementById("loading-screen").style.opacity=0;
    setTimeout(()=>{ document.getElementById("loading-screen").style.display='none'; },500);

    if(typeof lucide !== 'undefined' && typeof lucide.createIcons === 'function') {
        lucide.createIcons();
    }
    
    // Fix: Initial render after UI is set up and data is presumed loaded
    render();
}
        // Function to hide loading screen - MULTIPLE METHODS to ensure it works
        function hideLoadingScreen() {
            console.log("hideLoadingScreen called");
            try {
                const loadingScreen = document.getElementById("loading-screen");
                if(loadingScreen) {
                    console.log("Found loading screen, hiding it...");
                    // Method 1: Fade out then hide
                    loadingScreen.style.opacity = "0";
                    loadingScreen.style.transition = "opacity 0.5s ease";
                    setTimeout(()=>{ 
                        loadingScreen.style.display='none';
                        loadingScreen.style.visibility='hidden';
                        console.log("Loading screen hidden");
                    }, 500);
                } else {
                    console.warn("Loading screen element not found!");
                    // Method 2: Force hide with CSS injection
                    try {
                        const style = document.createElement('style');
                        style.textContent = '#loading-screen { display: none !important; opacity: 0 !important; visibility: hidden !important; }';
                        document.head.appendChild(style);
                        console.log("Forced hide with CSS");
                    } catch(e2) {
                        console.error("Could not force hide:", e2);
                    }
                }
            } catch(e) {
                console.error("Error hiding loading screen:", e);
                // Method 3: Last resort - direct CSS
                try {
                    document.getElementById("loading-screen").style.cssText = "display: none !important; opacity: 0 !important; visibility: hidden !important;";
                } catch(e3) {
                    console.error("Complete failure to hide loading screen:", e3);
                }
            }
        }
        
        // Make hideLoadingScreen globally available for debugging
        window.hideLoadingScreen = hideLoadingScreen;
        
        // Update loading progress
        function updateLoadingProgress(percent, text) {
            const subtext = document.getElementById("loading-subtext");
            if(subtext && text) subtext.textContent = text;
        }
        
        function initApp() {
            console.log("initApp called");
            
            try {
                // Load both Arctic Data and World Map
                const startTime = performance.now();
                updateLoadingProgress(10, "Loading Arctic data and map...");
                
                // Try to load data, but don't block if it fails
                Promise.all([
                    fetch("modis_arctic_2023.json").then(r => {
                        if(!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }).catch(e => {
                        console.warn("Failed to load Arctic data:", e);
                        return null;
                    }),
                    d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").catch(e => {
                        console.warn("Failed to load map data:", e);
                        return null;
                    })
                ]).then(([arcticData, worldData]) => {
                    const loadTime = performance.now() - startTime;
                    console.log(`Data loading attempt completed in ${loadTime.toFixed(2)}ms`);
                    
                    // Store Arctic data if available
                    if(arcticData && Array.isArray(arcticData)) {
                        ARCTIC_DATA = arcticData;
                        LOCATIONS = [...new Set(arcticData.map(d=>d.site))];
                        console.log(`Loaded ${ARCTIC_DATA.length} data points from ${LOCATIONS.length} locations`);
                    } else {
                        console.warn("Arctic data not available, using empty data");
                        ARCTIC_DATA = [];
                        LOCATIONS = [];
                    }
                    
                    updateLoadingProgress(90, "Initializing visualization...");
                    
                    // Draw map if data available
                    if(worldData) {
                        try {
                            drawMap(worldData);
                        } catch(e) {
                            console.error("Error drawing map:", e);
                        }
                    }
                    
                    // Initialize UI (this will work even without data)
                    try {
                        initializeUI();
                    } catch(e) {
                        console.error("Error in initializeUI:", e);
                        hideLoadingScreen();
                    }
                    
                    // Initialize snow
                    try {
                        const snowContainer = document.getElementById("snow-container");
                        if(snowContainer) {
                            snowContainer.style.opacity = 1; 
                            snowContainer.style.zIndex = 100;
                        }
                    } catch(e) {
                        console.error("Error initializing snow:", e);
                    }
                    
                    // Set up scroll handler
                    try {
                        window.addEventListener('scroll', handleScroll);
                        handleScroll(); // Initial call
                    } catch(e) {
                        console.error("Error setting up scroll handler:", e);
                    }
                    
                    // Animate intro
                    setTimeout(() => {
                        try {
                            document.querySelectorAll('#intro-section .fade-in').forEach(e => e.classList.add('visible'));
                        } catch(e) {
                            console.error("Error animating intro:", e);
                        }
                    }, 100);

                }).catch(error => {
                    console.error("Error in Promise.all:", error);
                    updateLoadingProgress(0, "Error loading data. Continuing anyway...");
                    
                    // Initialize with empty data so page still works
                    ARCTIC_DATA = [];
                    LOCATIONS = [];
                    
                    try {
                        initializeUI();
                    } catch(e) {
                        console.error("Error initializing with empty data:", e);
                        hideLoadingScreen();
                    }
                });
            } catch(error) {
                console.error("Error in initApp:", error);
                hideLoadingScreen();
                // Try to at least show the page
                ARCTIC_DATA = [];
                LOCATIONS = [];
                try {
                    initializeUI();
                } catch(e) {
                    console.error("Complete failure to initialize:", e);
                }
            }
        }

        // Scroll lock mechanism
        let isScrollLocked = false;
        let maxScrollPosition = 0;
        let lastScrollY = 0;
        
        // Prevent wheel scrolling past the lock point
        window.addEventListener('wheel', function(e) {
            if(isScrollLocked && !state.hasReached24Hours) {
                const visSection = document.getElementById('visualization-section');
                if(visSection) {
                    const visSectionTop = visSection.offsetTop;
                    const visSectionHeight = visSection.offsetHeight;
                    const maxAllowedScroll = visSectionTop + visSectionHeight - window.innerHeight;
                    const currentScroll = window.scrollY;
                    
                    // If trying to scroll down past the lock point, prevent it
                    if(e.deltaY > 0 && currentScroll >= maxAllowedScroll - 10) {
                        e.preventDefault();
                        return false;
                    }
                }
            }
        }, { passive: false });
        
        // Prevent touch scrolling past the lock point
        let touchStartY = 0;
        window.addEventListener('touchstart', function(e) {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        window.addEventListener('touchmove', function(e) {
            if(isScrollLocked && !state.hasReached24Hours) {
                const visSection = document.getElementById('visualization-section');
                if(visSection) {
                    const visSectionTop = visSection.offsetTop;
                    const visSectionHeight = visSection.offsetHeight;
                    const maxAllowedScroll = visSectionTop + visSectionHeight - window.innerHeight;
                    const currentScroll = window.scrollY;
                    const touchY = e.touches[0].clientY;
                    const deltaY = touchStartY - touchY; // Positive means scrolling down
                    
                    // If trying to scroll down past the lock point, prevent it
                    if(deltaY < 0 && currentScroll >= maxAllowedScroll - 10) {
                        e.preventDefault();
                        return false;
                    }
                }
            }
        }, { passive: false });

        function handleScroll() {
            const hookSection = document.getElementById('hook-section');
            const visSection = document.getElementById('visualization-section');
            const factsSection = document.getElementById('facts-section');
            const narrativeSection = document.getElementById('narrative-storytelling-section');
            
            const scrollY = window.scrollY;

            // Calculate progress for the hook/map section
            const hookRect = hookSection.getBoundingClientRect();
            let hookProgress = 1 - (hookRect.bottom / hookRect.height);
            hookProgress = Math.max(0, Math.min(1, hookProgress));

            // Calculate progress for the visualization section
            const visRect = visSection.getBoundingClientRect();
            let visProgress = 1 - (visRect.bottom / visRect.height);
            visProgress = Math.max(0, Math.min(1, visProgress));
            
            state.scrollProgress = visProgress;
            
            // Check if user has reached 24 hours (100% progress)
            if(visProgress >= 0.99 && !state.hasReached24Hours) {
                state.hasReached24Hours = true;
                isScrollLocked = false; // Unlock scrolling
                console.log("24 hours reached! Scrolling unlocked.");
            }
            
            // Lock scroll if user hasn't reached 24 hours yet and is trying to scroll past visualization
            const lockMessage = document.getElementById("lock-message");
            if(!state.hasReached24Hours && visProgress >= 0.99) {
                // Calculate the maximum allowed scroll position (end of visualization section)
                const visSectionTop = visSection.offsetTop;
                const visSectionHeight = visSection.offsetHeight;
                const maxAllowedScroll = visSectionTop + visSectionHeight - window.innerHeight;
                
                if(scrollY >= maxAllowedScroll - 10) { // Small buffer
                    // Prevent scrolling past
                    window.scrollTo({
                        top: maxAllowedScroll,
                        behavior: 'auto'
                    });
                    isScrollLocked = true;
                    
                    // Show lock message
                    if(lockMessage) {
                        lockMessage.classList.remove('hidden');
                    }
                } else {
                    // Hide lock message if not at the end
                    if(lockMessage) {
                        lockMessage.classList.add('hidden');
                    }
                }
            } else {
                // Hide lock message when unlocked
                if(lockMessage) {
                    lockMessage.classList.add('hidden');
                }
            }
            
            // Update the map visualization
            if (typeof updateMapProjection === 'function' && hookProgress > 0 && hookProgress < 1) {
                updateMapProjection(hookProgress);
            } else if (hookProgress >= 1) {
                // Map section is done, ensure visualization is visible
                const appContainer = document.getElementById("app-container");
                if(appContainer) {
                    appContainer.style.opacity = 1;
                }
            } else {
                // Still in map section
                const appContainer = document.getElementById("app-container");
                if(appContainer && hookProgress < 0.75) {
                    appContainer.style.opacity = 0;
                }
            }

            // Update the main visualization (day/time cycle)
            if (visProgress > 0 && visProgress <= 1) {
                state.currentSection = 'visualization';
                updateTimeCycle(visProgress);
                
                // Make visualization visible - start showing it as map fades (around 75% of hook)
                const appContainer = document.getElementById("app-container");
                if(appContainer) {
                    if(hookProgress >= 0.75) {
                        // Transition period - fade in visualization as map fades
                        const transitionProgress = (hookProgress - 0.75) / 0.25;
                        appContainer.style.opacity = Math.min(1, transitionProgress);
                    } else if(visProgress > 0) {
                        // Fully in visualization section
                        appContainer.style.opacity = 1;
                    }
                }
            } else if (visProgress <= 0) {
                state.currentSection = 'hook';
                const appContainer = document.getElementById("app-container");
                if(appContainer && hookProgress < 0.75) {
                    appContainer.style.opacity = 0;
                }
            }

            // Generic fade-in for all sections after vis
            const chartSection = document.getElementById('chart-section');
            const seasonalComparisonSection = document.getElementById('seasonal-comparison-section');
            const quizSection = document.getElementById('quiz-section');
            const calculatorSection = document.getElementById('interactive-calculator-section');
            const takeawaySection = document.getElementById('final-takeaway-section');
            const bridgeSection = document.getElementById('story-bridge-section');
            const sectionsToAnimate = [bridgeSection, narrativeSection, chartSection, factsSection, seasonalComparisonSection, calculatorSection, quizSection, takeawaySection];
            
            sectionsToAnimate.forEach(section => {
                if (!section) return;
                const rect = section.getBoundingClientRect();
                if (rect.top < window.innerHeight * 0.75) {
                    section.querySelectorAll('.fade-in').forEach(el => el.classList.add('visible'));
                    section.querySelectorAll('.story-point').forEach(el => el.classList.add('visible'));
                    section.querySelectorAll('.season-fact-card').forEach(el => el.classList.add('visible'));
                    section.querySelectorAll('.takeaway-stat').forEach((el, i) => {
                        setTimeout(() => el.style.opacity = '1', i * 100);
                    });
                }
            });
            
            // Animate line chart when it comes into view - lines draw from left to right
            if (chartSection && window.iceLinePath && window.daylightLinePath) {
                const chartRect = chartSection.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const sectionTop = chartRect.top;
                const sectionBottom = chartRect.bottom;
                
                // Calculate progress: start animating when section enters viewport
                let chartProgress = 0;
                if (sectionTop < viewportHeight * 0.8 && sectionBottom > viewportHeight * 0.2) {
                    // Section is in the middle 60% of viewport - animate based on position
                    // Progress from 0 (section entering) to 1 (section centered)
                    const animationStart = viewportHeight * 0.8;
                    const animationEnd = viewportHeight * 0.2;
                    const animationRange = animationStart - animationEnd;
                    const currentPos = sectionTop;
                    chartProgress = Math.max(0, Math.min(1, (animationStart - currentPos) / animationRange));
                }
                
                const icePath = window.iceLinePath.node();
                const daylightPath = window.daylightLinePath.node();
                
                if (icePath && daylightPath) {
                    const iceTotalLength = icePath.getTotalLength();
                    const daylightTotalLength = daylightPath.getTotalLength();
                    
                    // Lines start completely hidden (dashoffset = totalLength), then reveal as we scroll
                    // When chartProgress = 0, dashoffset = totalLength (fully hidden)
                    // When chartProgress = 1, dashoffset = 0 (fully visible)
                    window.iceLinePath
                        .attr("stroke-dashoffset", iceTotalLength * (1 - chartProgress));
                    window.daylightLinePath
                        .attr("stroke-dashoffset", daylightTotalLength * (1 - chartProgress));
                    
                    // Animate dots as line progresses (show dots after 50% of line is drawn)
                    if (window.iceDots && window.daylightDots) {
                        const dotProgress = Math.max(0, Math.min(1, (chartProgress - 0.5) / 0.5));
                        window.iceDots
                            .attr("r", 5 * dotProgress)
                            .attr("opacity", 0.8 * dotProgress);
                        window.daylightDots
                            .attr("r", 5 * dotProgress)
                            .attr("opacity", 0.8 * dotProgress);
                    }
                }
            }
            
            // Animate bar chart when it comes into view - bars grow from bottom as we scroll
            if (seasonalComparisonSection && window.seasonalIceBars && window.seasonalDaylightBars && window.seasonalChartData) {
                const barRect = seasonalComparisonSection.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const sectionTop = barRect.top;
                const sectionBottom = barRect.bottom;
                
                // Calculate progress: start animating when section enters viewport
                let barProgress = 0;
                if (sectionTop < viewportHeight * 0.8 && sectionBottom > viewportHeight * 0.2) {
                    // Section is in the middle 60% of viewport - animate based on position
                    const animationStart = viewportHeight * 0.8;
                    const animationEnd = viewportHeight * 0.2;
                    const animationRange = animationStart - animationEnd;
                    const currentPos = sectionTop;
                    barProgress = Math.max(0, Math.min(1, (animationStart - currentPos) / animationRange));
                }
                
                // Animate bars progressively based on scroll
                window.seasonalIceBars.each(function(d, i) {
                    const bar = d3.select(this);
                    const targetHeight = window.seasonalHeight - window.seasonalYScaleIce(d.seaIce);
                    const targetY = window.seasonalYScaleIce(d.seaIce);
                    
                    // Each bar starts animating slightly after the previous one
                    const barStartProgress = i * 0.12; // First bar at 0%, second at 12%, etc.
                    const barEndProgress = barStartProgress + 0.25; // Each bar takes 25% of scroll
                    const barAnimationProgress = Math.max(0, Math.min(1, (barProgress - barStartProgress) / (barEndProgress - barStartProgress)));
                    
                    const currentHeight = targetHeight * barAnimationProgress;
                    const currentY = window.seasonalHeight - currentHeight;
                    
                    bar.attr("y", currentY)
                       .attr("height", currentHeight);
                });
                
                window.seasonalDaylightBars.each(function(d, i) {
                    const bar = d3.select(this);
                    const targetHeight = window.seasonalHeight - window.seasonalYScaleDaylight(d.daylightHours);
                    const targetY = window.seasonalYScaleDaylight(d.daylightHours);
                    
                    // Each bar starts animating slightly after the previous one
                    const barStartProgress = i * 0.12; // First bar at 0%, second at 12%, etc.
                    const barEndProgress = barStartProgress + 0.25; // Each bar takes 25% of scroll
                    const barAnimationProgress = Math.max(0, Math.min(1, (barProgress - barStartProgress) / (barEndProgress - barStartProgress)));
                    
                    const currentHeight = targetHeight * barAnimationProgress;
                    const currentY = window.seasonalHeight - currentHeight;
                    
                    bar.attr("y", currentY)
                       .attr("height", currentHeight);
                });
            }

            // Update narrative section content visibility (basic approach)
            if (narrativeSection) {
                const storyAnd = document.getElementById('story-and');
                const storyBut = document.getElementById('story-but');
                const storyTherefore = document.getElementById('story-therefore');
                
                // Simple sequential visibility based on scroll position within the narrative section
                const narrativeRect = narrativeSection.getBoundingClientRect();
                const narrativeStart = narrativeRect.top + window.scrollY;
                const narrativeEnd = narrativeRect.bottom + window.scrollY;
                const sectionLength = (narrativeEnd - narrativeStart) / 3;

                if (scrollY > narrativeStart + sectionLength * 0.25) {
                    storyAnd.classList.add('visible');
                }
                if (scrollY > narrativeStart + sectionLength * 1.25) {
                    storyBut.classList.add('visible');
                }
                if (scrollY > narrativeStart + sectionLength * 2.25) {
                    storyTherefore.classList.add('visible');
                }
            }
        }

        
        function initializeSeasonalFacts(){
            const container = document.getElementById("seasonal-facts-container");
            if(!container) return;
            container.innerHTML = '';
    
            SEASONS.forEach((season, seasonIndex) => {
            const seasonData = SEASONAL_FACTS[season];
            if(!seasonData) return;
        
        // Create season section
        const seasonSection = document.createElement("div");
        seasonSection.className = "mb-16 fade-in";
        seasonSection.style.transitionDelay = `${seasonIndex * 0.2}s`;
        
        // Get daylight hours from data if available
        let daylightHours = seasonData.daylightHours;
        if(ARCTIC_DATA.length > 0) {
            const seasonDataPoints = ARCTIC_DATA.filter(d => d.season === season && d.site === state.location);
            if(seasonDataPoints.length > 0) {
                const minDaylight = Math.min(...seasonDataPoints.map(d => d.daylightHours));
                const maxDaylight = Math.max(...seasonDataPoints.map(d => d.daylightHours));
                daylightHours = `${minDaylight.toFixed(1)}-${maxDaylight.toFixed(1)} hours`;
            }
        }
        
        // Color scheme based on season
        const seasonColors = {
            Winter: { gradient: 'from-blue-600 via-indigo-600 to-blue-800', border: 'border-blue-400/50', bg: 'bg-blue-500/20', text: 'text-blue-200' },
            Spring: { gradient: 'from-green-500 via-emerald-500 to-teal-500', border: 'border-green-400/50', bg: 'bg-green-500/20', text: 'text-green-200' },
            Summer: { gradient: 'from-yellow-500 via-orange-500 to-red-500', border: 'border-yellow-400/50', bg: 'bg-yellow-500/20', text: 'text-yellow-200' },
            Fall: { gradient: 'from-orange-600 via-amber-600 to-yellow-600', border: 'border-orange-400/50', bg: 'bg-orange-500/20', text: 'text-orange-200' }
        };
        const colors = seasonColors[season] || seasonColors.Winter;
        
        seasonSection.innerHTML = `
            <div class="text-center mb-12 relative">
                <div class="absolute inset-0 flex items-center justify-center">
                    <div class="w-full max-w-2xl h-px bg-gradient-to-r from-transparent via-white/20 to-transparent"></div>
                </div>
                <h3 class="text-4xl md:text-6xl font-black mb-4 relative z-10">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r ${colors.gradient}">${season.toUpperCase()}</span>
                </h3>
                <div class="flex items-center justify-center gap-4 mb-4 relative z-10">
                    <div class="flex items-center gap-3 px-6 py-3 ${colors.bg} rounded-full border-2 ${colors.border} backdrop-blur-sm shadow-lg">
                        <i data-lucide="sun" class="w-6 h-6 text-yellow-300 drop-shadow-lg"></i>
                        <span class="${colors.text} font-bold text-lg">${daylightHours}</span>
                    </div>
                </div>
                <p class="text-blue-200/90 text-xl max-w-3xl mx-auto leading-relaxed relative z-10 font-medium">${seasonData.description}</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="facts-${season.toLowerCase()}"></div>
        `;
        
        container.appendChild(seasonSection);
        
        // Add facts for this season with reveal mechanism
        const factsGrid = document.getElementById(`facts-${season.toLowerCase()}`);
        seasonData.facts.forEach((f, factIndex) => {
            const card = document.createElement("div");
            card.className = "season-fact-card fade-in relative overflow-hidden";
            card.style.transitionDelay = `${(seasonIndex * 0.2) + (factIndex * 0.1)}s`;
            card.dataset.revealed = "false";
            
            // Extract key stat from content if possible
            const statMatch = f.content.match(/(\d+(?:\.\d+)?)\s*(pounds?|lbs?|hours?|h|miles?|mph|inches?|cm|%)/i);
            const statText = statMatch ? `${statMatch[1]} ${statMatch[2]}` : null;
            
            // Enhanced card with reveal mechanism
            card.innerHTML = `
                <div class="fact-reveal-overlay">
                    <button class="reveal-button">
                        <span class="flex items-center gap-2">
                            <i data-lucide="eye" class="w-5 h-5"></i>
                            Reveal Secret
                        </span>
                    </button>
                </div>
                ${statText ? `<div class="fact-stat-badge">${statText}</div>` : ''}
                <div class="flex items-start space-x-4 mb-4 relative z-10">
                    <div class="p-4 bg-gradient-to-br from-blue-500/30 to-indigo-500/30 rounded-xl border border-blue-400/50 shadow-lg">
                        <i data-lucide="${f.icon}" class="w-7 h-7 text-blue-200 drop-shadow-lg"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="text-2xl font-black text-white mb-2 bg-gradient-to-r from-white to-blue-200 bg-clip-text text-transparent">${f.title}</h3>
                    </div>
                </div>
                <div class="fact-content-hidden">
                    <div class="mb-4 px-4 py-3 bg-gradient-to-r from-yellow-500/20 via-orange-500/15 to-yellow-500/20 border border-yellow-400/40 rounded-xl backdrop-blur-sm">
                        <p class="text-sm text-yellow-200 font-semibold flex items-center gap-2">
                            <i data-lucide="sun" class="w-4 h-4"></i>
                            ${f.daylightConnection}
                        </p>
                    </div>
                    <p class="text-blue-100/90 leading-relaxed relative z-10 text-lg">${f.content}</p>
                </div>
            `;

            // Add reveal functionality
            const revealOverlay = card.querySelector('.fact-reveal-overlay');
            const revealButton = card.querySelector('.reveal-button');
            const factContent = card.querySelector('.fact-content-hidden');
            
            const revealFact = () => {
                if (card.dataset.revealed === "true") return;
                card.dataset.revealed = "true";
                revealOverlay.classList.add('hidden');
                setTimeout(() => {
                    factContent.classList.remove('fact-content-hidden');
                    factContent.classList.add('fact-content-revealed');
                }, 300);
            };
            
            revealButton.addEventListener('click', revealFact);
            card.addEventListener('click', (e) => {
                if (e.target !== revealButton && !revealButton.contains(e.target)) {
                    revealFact();
                }
            });

            factsGrid.appendChild(card);
        });
    });
    
    lucide.createIcons();
    
    // Animate cards on scroll
    setTimeout(()=>{
        document.querySelectorAll('#facts-section .fade-in')
            .forEach(e=>e.classList.add('visible'));
    },100);
}
        
        
        // Quiz state for sequential flow
        let quizState = {
            currentIndex: 0,
            totalQuestions: QUIZ_QUESTIONS.length + GUESSING_GAMES.length,
            answered: []
        };

        function initializeQuizzes(){
            const c=document.getElementById("quiz-container");
            if(!c) return;
            c.innerHTML='';

            // Reset state
            quizState.currentIndex = 0;
            quizState.answered = [];

            // Combine all questions into a single array
            const allQuestions = [
                ...QUIZ_QUESTIONS.map((q, i) => ({ type: 'quiz', index: i, data: q })),
                ...GUESSING_GAMES.map((g, i) => ({ type: 'guess', index: i, data: g }))
            ];

            // Create container for sequential display
            const sequentialContainer = document.createElement("div");
            sequentialContainer.className = "w-full max-w-4xl mx-auto";
            sequentialContainer.id = "sequential-quiz-container";

            // Progress indicator
            const progressBar = document.createElement("div");
            progressBar.className = "mb-4";
            progressBar.innerHTML = `
                <div class="flex items-center justify-between mb-1">
                    <span class="text-blue-200 font-semibold text-sm">Question <span id="current-question-num">1</span> of ${allQuestions.length}</span>
                    <span class="text-blue-300/60 text-xs" id="quiz-progress-text">0% Complete</span>
                </div>
                <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                    <div id="quiz-progress-bar" class="h-full bg-gradient-to-r from-blue-500 to-indigo-500 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>
            `;
            sequentialContainer.appendChild(progressBar);

            // Create all question cards (initially hidden)
            allQuestions.forEach((item, globalIndex) => {
                const card = document.createElement("div");
                card.className = `quiz-card rounded-2xl p-8 fade-in relative overflow-hidden ${globalIndex === 0 ? '' : 'hidden'}`;
                card.id = `question-${globalIndex}`;
                card.dataset.questionIndex = globalIndex;

                // Add mouse tracking for interactive glow
                card.addEventListener('mousemove', function(e) {
                    const rect = this.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    this.style.setProperty('--mouse-x', x + '%');
                    this.style.setProperty('--mouse-y', y + '%');
                });

                if (item.type === 'quiz') {
                    const q = item.data;
                    const quizId = `quiz-${item.index}`;
                    card.innerHTML = `
                        <div class="flex items-start space-x-3 mb-3 relative z-10">
                            <div class="p-2 bg-gradient-to-br from-blue-500/40 to-indigo-500/30 rounded-lg border border-blue-400/60 shadow-lg">
                                <i data-lucide="help-circle" class="w-5 h-5 text-blue-200 drop-shadow-lg"></i>
                            </div>
                            <div class="flex-1">
                                <h3 class="text-lg font-black text-white mb-2 bg-gradient-to-r from-white via-blue-200 to-blue-300 bg-clip-text text-transparent">${q.question}</h3>
                            </div>
                        </div>
                        <div class="space-y-2 mb-3 relative z-10" id="${quizId}-options">
                            ${q.options.map((opt,j)=>`
                                <button class="quiz-option w-full text-left p-2.5 rounded-lg border-2 border-white/20 bg-gradient-to-r from-white/5 to-white/0 text-blue-100 font-medium text-sm transition-all duration-300" 
                                        data-quiz="${item.index}" data-option="${j}" data-global-index="${globalIndex}">
                                    <span class="relative z-10 flex items-center gap-2">
                                        <span class="w-5 h-5 rounded-full border-2 border-white/30 flex items-center justify-center text-xs font-bold">${String.fromCharCode(65 + j)}</span>
                                        ${opt}
                                    </span>
                                </button>
                            `).join('')}
                        </div>
                        <div id="${quizId}-result" class="hidden mt-3 p-3 rounded-lg relative z-10 backdrop-blur-md text-sm"></div>
                        <div id="next-button-${globalIndex}" class="hidden mt-3">
                            <button class="next-quiz-btn w-full py-2.5 px-4 bg-gradient-to-r from-indigo-500/60 to-purple-500/60 hover:from-indigo-500/80 hover:to-purple-500/80 rounded-lg text-white font-bold border-2 border-indigo-400/50 relative z-10 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 text-sm" 
                                    data-next-index="${globalIndex}">
                                <span class="flex items-center justify-center gap-2">
                                    <i data-lucide="arrow-right" class="w-4 h-4"></i>
                                    ${globalIndex < allQuestions.length - 1 ? 'Next Question' : 'View Results'}
                                </span>
                            </button>
                        </div>
                    `;
                } else {
                    const g = item.data;
                    const gameId = `guess-${item.index}`;
                    card.innerHTML = `
                        <div class="flex items-start space-x-3 mb-3 relative z-10">
                            <div class="p-2 bg-gradient-to-br from-yellow-500/40 to-orange-500/30 rounded-lg border border-yellow-400/60 shadow-lg">
                                <i data-lucide="${g.icon}" class="w-5 h-5 text-yellow-200 drop-shadow-lg"></i>
                            </div>
                            <div class="flex-1">
                                <h3 class="text-lg font-black text-white mb-2 bg-gradient-to-r from-yellow-200 via-orange-200 to-yellow-300 bg-clip-text text-transparent">${g.title}</h3>
                                <p class="text-blue-200/90 mb-3 text-sm">${g.question}</p>
                            </div>
                        </div>
                        <div class="flex gap-2 mb-3 relative z-10">
                            <input type="number" id="${gameId}-input" class="guess-input flex-1 px-3 py-2 rounded-lg text-white text-center text-base font-bold bg-gradient-to-r from-white/10 to-white/5 border-2 border-white/30 focus:border-blue-400/60" placeholder="Your guess" data-global-index="${globalIndex}">
                            <span class="text-blue-200 self-center text-sm font-semibold px-2">${g.unit}</span>
                        </div>
                        <button class="reveal-btn w-full py-2.5 px-4 bg-gradient-to-r from-blue-500/40 to-indigo-500/40 hover:from-blue-500/60 hover:to-indigo-500/60 rounded-lg text-white font-bold border-2 border-blue-400/50 relative z-10 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 text-sm" 
                                data-game="${item.index}" data-global-index="${globalIndex}">
                            <span class="flex items-center justify-center gap-2">
                                <i data-lucide="check-circle" class="w-4 h-4"></i>
                                Check Answer
                            </span>
                        </button>
                        <div id="${gameId}-result" class="hidden mt-3 p-3 rounded-lg relative z-10 backdrop-blur-md text-sm"></div>
                        <div class="mt-2 px-3 py-2 bg-gradient-to-r from-yellow-500/20 to-orange-500/15 border border-yellow-400/40 rounded-lg">
                            <p class="text-xs text-yellow-200 font-medium flex items-center gap-2">
                                <i data-lucide="lightbulb" class="w-3 h-3"></i>
                                üí° Hint: ${g.hint}
                            </p>
                        </div>
                        <div id="next-button-${globalIndex}" class="hidden mt-3">
                            <button class="next-quiz-btn w-full py-2.5 px-4 bg-gradient-to-r from-indigo-500/60 to-purple-500/60 hover:from-indigo-500/80 hover:to-purple-500/80 rounded-lg text-white font-bold border-2 border-indigo-400/50 relative z-10 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 text-sm" 
                                    data-next-index="${globalIndex}">
                                <span class="flex items-center justify-center gap-2">
                                    <i data-lucide="arrow-right" class="w-4 h-4"></i>
                                    ${globalIndex < allQuestions.length - 1 ? 'Next Question' : 'View Results'}
                                </span>
                            </button>
                        </div>
                    `;
                }
                sequentialContainer.appendChild(card);
            });

            // Completion message
            const completionCard = document.createElement("div");
            completionCard.className = "quiz-card rounded-2xl p-6 fade-in relative overflow-hidden hidden";
            completionCard.id = "quiz-completion";
            completionCard.innerHTML = `
                <div class="text-center">
                    <div class="text-4xl mb-3">üéâ</div>
                    <h3 class="text-2xl font-black text-white mb-2 bg-gradient-to-r from-green-300 via-emerald-300 to-cyan-300 bg-clip-text text-transparent">Quiz Complete!</h3>
                    <p class="text-blue-200/90 text-sm mb-4">You've answered all ${allQuestions.length} questions. Great job learning about polar bears!</p>
                    <button class="restart-quiz-btn px-6 py-2 bg-gradient-to-r from-blue-500/60 to-indigo-500/60 hover:from-blue-500/80 hover:to-indigo-500/80 rounded-lg text-white font-bold border-2 border-blue-400/50 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 text-sm">
                        <span class="flex items-center justify-center gap-2">
                            <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                            Restart Quiz
                        </span>
                    </button>
                </div>
            `;
            sequentialContainer.appendChild(completionCard);

            c.appendChild(sequentialContainer);

            // Add event listeners for quizzes
            document.querySelectorAll('.quiz-option').forEach(btn=>{
                btn.addEventListener('click', function(){
                    const quizId=parseInt(this.dataset.quiz);
                    const optionId=parseInt(this.dataset.option);
                    const globalIndex = parseInt(this.dataset.globalIndex);
                    handleQuizAnswer(quizId, optionId, this, globalIndex);
                });
            });

            // Add event listeners for guessing games
            document.querySelectorAll('[data-game]').forEach(btn=>{
                btn.addEventListener('click', function(){
                    const gameId=parseInt(this.dataset.game);
                    const globalIndex = parseInt(this.dataset.globalIndex);
                    handleGuessAnswer(gameId, globalIndex);
                });
            });

            // Add event listeners for Next buttons
            document.querySelectorAll('.next-quiz-btn').forEach(btn=>{
                btn.addEventListener('click', function(){
                    const nextIndex = parseInt(this.dataset.nextIndex) + 1;
                    showNextQuestion(nextIndex);
                });
            });

            // Add event listener for restart button
            document.querySelector('.restart-quiz-btn')?.addEventListener('click', function(){
                initializeQuizzes();
            });

            // Update progress
            updateQuizProgress();

            lucide.createIcons();
        }

        function showNextQuestion(nextIndex) {
            const allQuestions = QUIZ_QUESTIONS.length + GUESSING_GAMES.length;
            
            // Hide current question
            const currentCard = document.getElementById(`question-${quizState.currentIndex}`);
            if(currentCard) {
                currentCard.classList.add('hidden');
            }

            // Show next question or completion
            if(nextIndex >= allQuestions) {
                // Show completion
                const completionCard = document.getElementById('quiz-completion');
                if(completionCard) {
                    completionCard.classList.remove('hidden');
                }
            } else {
                const nextCard = document.getElementById(`question-${nextIndex}`);
                if(nextCard) {
                    nextCard.classList.remove('hidden');
                    // Don't scroll - stay in place
                }
            }

            quizState.currentIndex = nextIndex;
            updateQuizProgress();
        }

        function updateQuizProgress() {
            const currentNum = document.getElementById('current-question-num');
            const progressText = document.getElementById('quiz-progress-text');
            const progressBar = document.getElementById('quiz-progress-bar');
            
            if(currentNum) {
                const displayNum = Math.min(quizState.currentIndex + 1, quizState.totalQuestions);
                currentNum.textContent = displayNum;
            }
            
            if(progressText && progressBar) {
                const progress = (quizState.currentIndex / quizState.totalQuestions) * 100;
                progressText.textContent = `${Math.round(progress)}% Complete`;
                progressBar.style.width = `${progress}%`;
            }
        }

        function handleQuizAnswer(quizId, optionId, buttonElement, globalIndex){
            const quiz=QUIZ_QUESTIONS[quizId];
            const resultDiv=document.getElementById(`quiz-${quizId}-result`);
            const options=document.querySelectorAll(`[data-quiz="${quizId}"]`);
            const nextButton = document.getElementById(`next-button-${globalIndex}`);

            // Disable all options
            options.forEach(opt=>{
                opt.disabled=true;
                opt.classList.remove('selected');
            });

            // Mark selected
            buttonElement.classList.add('selected');

            // Show result
            resultDiv.classList.remove('hidden');
            if(optionId===quiz.correct){
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-green-500/30 to-emerald-500/20 border-2 border-green-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="p-1.5 bg-green-500/30 rounded-lg">
                            <i data-lucide="check-circle" class="w-4 h-4 text-green-300"></i>
                        </div>
                        <div>
                            <p class="text-green-300 font-black text-sm mb-1">‚úì Correct!</p>
                            <p class="text-green-200/90 text-xs leading-relaxed">${quiz.explanation}</p>
                        </div>
                    </div>
                `;
                buttonElement.classList.add('correct');
                lucide.createIcons();
            } else {
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-red-500/30 to-rose-500/20 border-2 border-red-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="p-1.5 bg-red-500/30 rounded-lg">
                            <i data-lucide="x-circle" class="w-4 h-4 text-red-300"></i>
                        </div>
                        <div>
                            <p class="text-red-300 font-black text-sm mb-1">‚úó Incorrect</p>
                            <p class="text-red-200/90 text-xs leading-relaxed">${quiz.explanation}</p>
                        </div>
                    </div>
                `;
                buttonElement.classList.add('incorrect');
                // Highlight correct answer
                options[quiz.correct].classList.add('correct');
                lucide.createIcons();
            }

            // Show Next button
            if(nextButton) {
                nextButton.classList.remove('hidden');
                quizState.answered[globalIndex] = true;
            }
        }

        function handleGuessAnswer(gameId, globalIndex){
            const game=GUESSING_GAMES[gameId];
            const input=document.getElementById(`guess-${gameId}-input`);
            const resultDiv=document.getElementById(`guess-${gameId}-result`);
            const nextButton = document.getElementById(`next-button-${globalIndex}`);
            const guess=parseFloat(input.value);

            if(!guess || isNaN(guess)){
                resultDiv.className="mt-4 p-3 rounded-lg bg-yellow-500/20 border border-yellow-400/50";
                resultDiv.innerHTML=`<p class="text-yellow-300">Please enter a number!</p>`;
                resultDiv.classList.remove('hidden');
                return;
            }

            // Disable input and check button
            input.disabled = true;
            const checkBtn = document.querySelector(`[data-game="${gameId}"][data-global-index="${globalIndex}"]`);
            if(checkBtn) checkBtn.disabled = true;

            resultDiv.classList.remove('hidden');
            const diff=Math.abs(guess-game.answer);
            const percentDiff=(diff/game.answer)*100;

            if(percentDiff<5){
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-green-500/30 to-emerald-500/20 border-2 border-green-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="text-xl">üéâ</div>
                        <div>
                            <p class="text-green-300 font-black text-sm mb-1">Excellent! You're very close!</p>
                            <p class="text-green-200/90 text-xs">The answer is <span class="font-bold text-green-300">${game.answer} ${game.unit}</span></p>
                        </div>
                    </div>
                `;
            } else if(percentDiff<15){
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-blue-500/30 to-cyan-500/20 border-2 border-blue-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="text-xl">üëç</div>
                        <div>
                            <p class="text-blue-300 font-black text-sm mb-1">Good guess!</p>
                            <p class="text-blue-200/90 text-xs">The answer is <span class="font-bold text-blue-300">${game.answer} ${game.unit}</span>. You were ${diff.toFixed(1)} ${game.unit} off.</p>
                        </div>
                    </div>
                `;
            } else if(guess<game.answer){
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-yellow-500/30 to-orange-500/20 border-2 border-yellow-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="text-xl">üìà</div>
                        <div>
                            <p class="text-yellow-300 font-black text-sm mb-1">Too low! Try a higher number.</p>
                            <p class="text-yellow-200/90 text-xs">The answer is <span class="font-bold text-yellow-300">${game.answer} ${game.unit}</span></p>
                        </div>
                    </div>
                `;
            } else {
                resultDiv.className="mt-3 p-3 rounded-lg bg-gradient-to-r from-yellow-500/30 to-orange-500/20 border-2 border-yellow-400/60 backdrop-blur-md shadow-lg";
                resultDiv.innerHTML=`
                    <div class="flex items-start gap-2">
                        <div class="text-xl">üìâ</div>
                        <div>
                            <p class="text-yellow-300 font-black text-sm mb-1">Too high! Try a lower number.</p>
                            <p class="text-yellow-200/90 text-xs">The answer is <span class="font-bold text-yellow-300">${game.answer} ${game.unit}</span></p>
                        </div>
                    </div>
                `;
            }

            // Show Next button
            if(nextButton) {
                nextButton.classList.remove('hidden');
                quizState.answered[globalIndex] = true;
            }
        }

        function renderSeasonalFacts(season) {
            const factsContainer = document.getElementById('seasonal-facts-container');
            const data = SEASONAL_FACTS[season];
            if (!data) return;

            factsContainer.innerHTML = `
                <div class="text-center mb-12">
                    <h3 class="text-3xl md:text-5xl font-extrabold text-blue-100">${season}</h3>
                    <p class="text-xl text-blue-200/80 mt-2">${data.description}</p>
                </div>
                <div class="season-facts-grid">
                    ${data.facts.map((fact, index) => `
                        <div class="season-fact-card fade-in" style="transition-delay: ${index * 0.15}s;">
                            <h4 class="text-xl font-bold mb-2 flex items-center gap-2 text-blue-300">
                                <i data-lucide="${fact.icon}" class="w-5 h-5"></i> ${fact.title}
                            </h4>
                            <p class="text-white/90">${fact.content}</p>
                            <div class="mt-3 pt-2 border-t border-white/10 text-xs text-blue-300/60 uppercase">
                                Connection to Daylight: ${fact.daylightConnection}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            // Replace lucide icons in the new content
            lucide.createIcons();
        }

       

        function initializeUI() {
            try {
                const c = document.getElementById("season-controls");
                if(!c) {
                    console.error("season-controls element not found");
                    hideLoadingScreen();
                    return;
                }
                c.innerHTML = '';
                SEASONS.forEach(s=>{
                    const b = document.createElement("button");
                    b.className = `flex-1 py-1 px-2 text-xs rounded-md transition-colors ${
                        s===state.season?'bg-white text-black font-bold':'text-white/60 hover:bg-white/10'
                    }`;
                    b.textContent=s;
                    b.onclick=()=>{ state.season=s; updateSeasonButtons(); render(); };
                    c.appendChild(b);
                });

                updateLocationDisplay();
                updateYearProgress();
                updateYearProgressBar(0);
                initializeQuizzes();
                initializeSeasonalFacts();
                initializeSurvivalCalculator();
                
                // Create the ice/daylight chart
                if(typeof createIceDaylightChart === 'function' && ARCTIC_DATA.length > 0) {
                    setTimeout(() => {
                        createIceDaylightChart();
                        createSeasonalComparisonChart();
                    }, 500);
                }

                // Hide loading screen after a brief delay
                setTimeout(() => {
                    hideLoadingScreen();
                }, 300);

                lucide.createIcons();
                
                // Render the visualization with the loaded data
                if(ARCTIC_DATA.length > 0) {
                    render();
                    console.log("Visualization rendered with data");
                } else {
                    console.warn("No data to render");
                }
            } catch(e) {
                console.error("Error in initializeUI:", e);
                console.error("Stack:", e.stack);
                hideLoadingScreen();
            }
        }
        
        // --- SURVIVAL IMPACT CALCULATOR ---
        function initializeSurvivalCalculator() {
            const iceSlider = document.getElementById('ice-slider');
            const fastingSlider = document.getElementById('fasting-slider');
            const weightSlider = document.getElementById('weight-slider');
            
            if (!iceSlider || !fastingSlider || !weightSlider) return;
            
            // Reset to default middle values on page load
            iceSlider.value = 50;
            fastingSlider.value = 90;
            weightSlider.value = 1250;
            
            function updateCalculator() {
                const ice = parseInt(iceSlider.value);
                const fastingDays = parseInt(fastingSlider.value);
                const startingWeight = parseInt(weightSlider.value);
                
                // Update display values
                document.getElementById('ice-value').textContent = ice + '%';
                document.getElementById('fasting-value').textContent = fastingDays + ' days';
                document.getElementById('weight-value').textContent = startingWeight.toLocaleString() + ' lbs';
                
                // Calculate weight loss (2 lbs per day during fasting)
                const weightLoss = fastingDays * 2;
                const finalWeight = startingWeight - weightLoss;
                const weightLossPercent = ((weightLoss / startingWeight) * 100).toFixed(1);
                
                // Update weight loss display
                document.getElementById('weight-loss-display').textContent = weightLoss + ' lbs';
                document.getElementById('weight-loss-percent').textContent = weightLossPercent + '% of body weight';
                document.getElementById('weight-loss-bar').style.width = Math.min(weightLossPercent, 100) + '%';
                
                // Determine survival status
                let status = 'Safe';
                let statusColor = 'text-green-300';
                let details = 'Bear maintains healthy weight';
                
                if (weightLossPercent > 30) {
                    status = 'Critical';
                    statusColor = 'text-red-400';
                    details = 'Life-threatening weight loss. Survival unlikely.';
                } else if (weightLossPercent > 20) {
                    status = 'At Risk';
                    statusColor = 'text-orange-400';
                    details = 'Significant weight loss. Bear is weakened.';
                } else if (weightLossPercent > 10) {
                    status = 'Vulnerable';
                    statusColor = 'text-yellow-400';
                    details = 'Moderate weight loss. Bear needs food soon.';
                }
                
                document.getElementById('survival-status').textContent = status;
                document.getElementById('survival-status').className = 'text-3xl font-black mb-2 ' + statusColor;
                document.getElementById('survival-details').textContent = details;
                
                // Determine hunting success based on ice coverage
                let huntingSuccess = 'High';
                let huntingDetails = 'Plenty of ice for seal hunting';
                let huntingColor = 'text-green-300';
                
                if (ice < 20) {
                    huntingSuccess = 'None';
                    huntingDetails = 'No ice platform. Cannot hunt seals.';
                    huntingColor = 'text-red-400';
                } else if (ice < 40) {
                    huntingSuccess = 'Low';
                    huntingDetails = 'Limited ice. Hunting opportunities rare.';
                    huntingColor = 'text-orange-400';
                } else if (ice < 60) {
                    huntingSuccess = 'Moderate';
                    huntingDetails = 'Some ice available. Limited hunting.';
                    huntingColor = 'text-yellow-400';
                }
                
                document.getElementById('hunting-success').textContent = huntingSuccess;
                document.getElementById('hunting-success').className = 'text-4xl font-black mb-2 ' + huntingColor;
                document.getElementById('hunting-details').textContent = huntingDetails;
            }
            
            // Add event listeners
            iceSlider.addEventListener('input', updateCalculator);
            fastingSlider.addEventListener('input', updateCalculator);
            weightSlider.addEventListener('input', updateCalculator);
            
            // Initial calculation
            updateCalculator();
        }

        function updateSeasonButtons() {
            const btns=document.getElementById("season-controls").querySelectorAll("button");
            btns.forEach((b,i)=>{
                const s = SEASONS[i];
                b.className = `flex-1 py-1 px-2 text-xs rounded-md transition-colors ${
                    s===state.season?'bg-white text-black font-bold':'text-white/60 hover:bg-white/10'
                }`;
            });
        }

        function updateLocationDisplay() {
            const t=document.getElementById("current-location-text");
            const d=document.getElementById("location-description");
            t.style.opacity=0; d.style.opacity=0;
            setTimeout(()=>{
                t.textContent=state.location;
                d.textContent="Polar Bear Territory";
                t.style.opacity=1; d.style.opacity=1;
            },200);
        }


        // STARS 
        function generateStars(){
    const l = document.getElementById("stars-layer");
    if(!l) return;
    l.innerHTML = "";
    for(let i = 0; i < 50; i++){
        const d = document.createElement("div");
        d.className = "absolute bg-white rounded-full star";
        d.style.top = Math.random() * 100 + "%";
        d.style.left = Math.random() * 100 + "%";
        const s = Math.random() * 3 + "px";
        d.style.width = s; 
        d.style.height = s;
        d.style.animationDelay = Math.random() * 3 + "s";
        l.appendChild(d);
    }
}
generateStars(); // Run once at initialization

function updateStars(h, season){
    const l = document.getElementById("stars-layer");
    if(!l) return;
    
    if(season === "Summer"){
        // Almost completely hidden due to midnight sun, faint only at darkest hours
        l.style.opacity = (h < 1 || h > 23) ? 0.05 : 0;
    } else {
        let n = 0; // Normalized opacity (0 to 1)
        if(h >= 18) n = (h - 18) / 6; // Fade in from 18:00 to 24:00
        else if(h < 6) n = (6 - h) / 6; // Fade out from 0:00 to 6:00
        
        n = Math.min(Math.max(n, 0), 1);
        l.style.opacity = n;
    }
}
        // CLOUDS
        let cloudsArray = [];
let cloudTargetPercent = 50;

function generateClouds(p = 50){
    const l = document.getElementById("clouds-layer");
    if(!l) return;
    l.innerHTML = "";
    cloudsArray = [];
    cloudTargetPercent = p;
    const norm = normalizeCloudPercent(p);
    const count = getCloudCount(norm).numClouds;
    for(let i = 0; i < count; i++){
        const c = createCloud(norm);
        l.appendChild(c);
        cloudsArray.push(c);
    }
}
generateClouds(); // Run once at initialization

function createCloud(n){
    const c = document.createElement("div");
    c.className = "absolute cloud";
    c.style.top = Math.random() * 70 + "%";
    c.style.left = Math.random() * 100 + "%";
    c.dataset.speed = (0.001 + Math.random() * 0.005) * (0.5 + n);
    c.style.opacity = 0.1 + n * 0.6;
    const num = 5 + Math.floor(Math.random() * 3);
    const bw = 80 + Math.random() * 120;
    const bh = 60 + Math.random() * 40;
    const mid = (num - 1) / 2;
    for(let j = 0; j < num; j++){
        const d = document.createElement("div");
        const dist = Math.abs(j - mid);
        const sf = 1 - dist / mid * 0.5;
        const wf = (0.8 + 0.4 * sf) * (0.9 + 0.1 * n);
        const hf = (0.8 + 0.8 * sf) * (0.9 + 0.4 * n);
        d.style.width = bw * wf * (0.9 + Math.random() * 0.2) + "px";
        d.style.height = bh * hf * (0.9 + Math.random() * 0.2) + "px";
        d.style.background = "white";
        d.style.borderRadius = "50%";
        d.style.position = "absolute";
        d.style.left = (j * bw * 0.35) + "px";
        d.style.top = (bh - bh * hf) + "px";
        d.style.filter = `blur(${2 + Math.random() * 3}px)`;
        c.appendChild(d);
    }
    return c;
}

function animateClouds(){
    cloudsArray.forEach(c => {
        let x = parseFloat(c.style.left);
        x += parseFloat(c.dataset.speed);
        if(x > 100) x = -50;
        c.style.left = x + "%";
    });
    // This creates a continuous loop
    requestAnimationFrame(animateClouds);
}
animateClouds(); // Start the animation loop

function normalizeCloudPercent(p){
    const min = 45, max = 80;
    // Maps the range [min, max] to [0, 1]
    return Math.min(Math.max((p - min) / (max - min), 0), 1);
}

function getCloudCount(n){
    const min = 3, max = 20;
    return {numClouds: Math.round(min + n * (max - min))};
}

function updateCloudsDensity(percent){
    // Only redraw the clouds if the density changes significantly (> 5%)
    if(Math.abs(percent - cloudTargetPercent) > 5){
        generateClouds(percent);
    }
}

        // SNOW
        function generateSnow(){
            const container=document.getElementById("snow-container");
            if(!container) return;
            container.innerHTML="";
            
            const snowflakeSymbols = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚úΩ', '‚úæ', '‚úø'];
            
            // Create more snowflakes for better effect
            for(let i=0;i<150;i++){
                const flake=document.createElement("div");
                flake.className="snowflake";
                flake.textContent=snowflakeSymbols[Math.floor(Math.random()*snowflakeSymbols.length)];
                
                // Vary sizes more
                const size=Math.random()*1.2+0.3;
                flake.style.fontSize=size+"em";
                flake.style.left=Math.random()*100+"%";
                flake.style.opacity=Math.random()*0.7+0.3;
                
                // Vary speeds - some fall faster, some slower
                const duration=Math.random()*15+8;
                flake.style.animationDuration=duration+"s";
                flake.style.animationDelay=Math.random()*5+"s";
                flake.style.setProperty("--drift", (Math.random()*100-50)+"px");
                container.appendChild(flake);
            }
        }
        
        function generateMapSnow(){
            const container=document.getElementById("map-snow-container");
            if(!container) return;
            container.innerHTML="";
            
            const snowflakeSymbols = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚úΩ', '‚úæ', '‚úø'];
            
            // Create fewer snowflakes that fall slower for transition effect
            for(let i=0;i<80;i++){
                const flake=document.createElement("div");
                flake.className="snowflake";
                flake.textContent=snowflakeSymbols[Math.floor(Math.random()*snowflakeSymbols.length)];
                
                // Smaller and slower for map section
                const size=Math.random()*0.8+0.2;
                flake.style.fontSize=size+"em";
                flake.style.left=Math.random()*100+"%";
                flake.style.opacity=Math.random()*0.5+0.2;
                
                // Slower animation for transition effect
                const duration=Math.random()*25+20; // Much slower (20-45 seconds)
                flake.style.animationDuration=duration+"s";
                flake.style.animationDelay=Math.random()*10+"s";
                flake.style.setProperty("--drift", (Math.random()*80-40)+"px");
                container.appendChild(flake);
            }
        }
        
        generateSnow();
        generateMapSnow();
        
        // Ensure page loads even if there are errors
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error, e.message, e.filename, e.lineno);
            hideLoadingScreen();
        });
        
        // Immediate fallback - hide loading screen after 2 seconds no matter what
        setTimeout(() => {
            console.log("Immediate fallback (2s) - ensuring page is visible");
            hideLoadingScreen();
        }, 2000);
        
        // Timeout fallback - hide loading screen after 8 seconds
        setTimeout(() => {
            console.warn("Timeout fallback (8s) - hiding loading screen");
            hideLoadingScreen();
        }, 8000);
        
        // Start the application
        console.log("Script loaded, readyState:", document.readyState);
        if(document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log("DOMContentLoaded fired");
                setTimeout(initApp, 100);
            });
        } else {
            // DOM already loaded
            console.log("DOM already loaded, calling initApp");
            setTimeout(initApp, 100);
        }
    </script>
</body>
</html>